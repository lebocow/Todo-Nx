File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/.eslintrc.json
{
  "extends": ["../../.eslintrc.json"],
  "ignorePatterns": ["!**/*"],
  "overrides": [
    {
      "files": ["*.ts", "*.tsx", "*.js", "*.jsx"],
      "rules": {}
    },
    {
      "files": ["*.ts", "*.tsx"],
      "rules": {}
    },
    {
      "files": ["*.js", "*.jsx"],
      "rules": {}
    },
    {
      "files": ["*.json"],
      "parser": "jsonc-eslint-parser",
      "rules": {
        "@nx/dependency-checks": [
          "error",
          {
            "ignoredFiles": ["{projectRoot}/esbuild.config.{js,ts,mjs,mts}"]
          }
        ]
      }
    }
  ]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/jest.config.ts
/* eslint-disable */
export default {
  displayName: 'data-models',
  preset: '../../jest.preset.js',
  testEnvironment: 'node',
  transform: {
    '^.+\\.[tj]s$': ['ts-jest', { tsconfig: '<rootDir>/tsconfig.spec.json' }],
  },
  moduleFileExtensions: ['ts', 'js', 'html'],
  coverageDirectory: '../../coverage/shared/data-models',
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/package.json
{
  "name": "@myworkspace/data-models",
  "version": "0.0.1",
  "dependencies": {},
  "type": "commonjs",
  "main": "./index.cjs",
  "private": true
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/project.json
{
  "name": "data-models",
  "$schema": "../../node_modules/nx/schemas/project-schema.json",
  "sourceRoot": "shared/data-models/src",
  "projectType": "library",
  "tags": [],
  "targets": {
    "build": {
      "executor": "@nx/esbuild:esbuild",
      "outputs": ["{options.outputPath}"],
      "options": {
        "outputPath": "dist/shared/data-models",
        "main": "shared/data-models/src/index.ts",
        "tsConfig": "shared/data-models/tsconfig.lib.json",
        "assets": [],
        "format": ["cjs"]
      }
    },
    "test": {
      "executor": "@nx/jest:jest",
      "outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
      "options": {
        "jestConfig": "shared/data-models/jest.config.ts"
      }
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/src/index.ts
export * from './lib/auth';
export * from './lib/category';
export * from './lib/task';
export * from './lib/user';
export * from './lib/token';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/src/lib/auth/auth.response.schema.ts
import { z } from 'zod';
import { BaseUserSchema } from '../user';
import { TokensSchema } from '../token';

export const AuthResponseSchema = z.object({
  user: BaseUserSchema,
  tokens: TokensSchema,
});

export type IAuthResponse = z.infer<typeof AuthResponseSchema>;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/src/lib/auth/auth.schema.ts
import { z } from 'zod';

export const LoginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});

export type ILoginInput = z.infer<typeof LoginSchema>;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/src/lib/auth/index.ts
export * from './auth.schema';
export * from './auth.response.schema';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/src/lib/category/category.schema.ts
import { z } from 'zod';

export const CategorySchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
});

export type ICategory = z.infer<typeof CategorySchema>;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/src/lib/category/index.ts
export * from './category.schema';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/src/lib/task/index.ts
export * from './task.schema';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/src/lib/task/task.schema.ts
import { z } from 'zod';

export const TaskSchema = z.object({
  id: z.string().uuid(),
  createdAt: z.date(),
  updatedAt: z.date(),
  title: z.string(),
  description: z.string().optional(),
  dueDate: z.date().optional(),
  completed: z.boolean(),
  categoryId: z.string().uuid(),
  userId: z.string().uuid(),
});

export type ITask = z.infer<typeof TaskSchema>;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/src/lib/token/index.ts
export * from './token.schema';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/src/lib/token/token.schema.ts
import { TokenType } from '@prisma/client';
import { z } from 'zod';

export const TokenSchema = z.object({
  token: z.string(),
  expires: z.number().int().positive(),
  type: z.nativeEnum(TokenType),
});

export const TokensSchema = z.object({
  access: TokenSchema,
  refresh: TokenSchema,
});

export type IToken = z.infer<typeof TokenSchema>;
export type ITokens = z.infer<typeof TokensSchema>;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/src/lib/user/index.ts
export * from './user.schema';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/src/lib/user/user.schema.ts
import { z } from 'zod';

export const BaseUserSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email(),
  name: z.string(),
  createdAt: z.date(),
  updatedAt: z.date(),
});

export const RegistrationSchema = BaseUserSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true,
})
  .extend({
    password: z.string().min(8),
    passwordConfirmation: z.string().min(8),
  })
  .refine((data) => data.password === data.passwordConfirmation, {
    message: "Passwords don't match",
    path: ['passwordConfirmation'],
  });

export const UpdatePasswordSchema = z
  .object({
    oldPassword: z.string(),
    newPassword: z.string().min(8),
    newPasswordConfirmation: z.string().min(8),
  })
  .refine((data) => data.newPassword === data.newPasswordConfirmation, {
    message: "New passwords don't match",
    path: ['newPasswordConfirmation'],
  });

export type IUser = z.infer<typeof BaseUserSchema>;
export type IRegistration = z.infer<typeof RegistrationSchema>;
export type IUpdatePassword = z.infer<typeof UpdatePasswordSchema>;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.lib.json"
    },
    {
      "path": "./tsconfig.spec.json"
    }
  ]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/tsconfig.lib.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "declaration": true,
    "types": ["node"]
  },
  "include": ["src/**/*.ts"],
  "exclude": ["jest.config.ts", "src/**/*.spec.ts", "src/**/*.test.ts"]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/shared/data-models/tsconfig.spec.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "module": "commonjs",
    "types": ["jest", "node"]
  },
  "include": [
    "jest.config.ts",
    "src/**/*.test.ts",
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}


ib/components/navbar/navbar.component.ts
import { ChangeDetectionStrategy, Component, input } from '@angular/core';
import { AsyncPipe } from '@angular/common';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatButtonModule } from '@angular/material/button';
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatListModule } from '@angular/material/list';
import { MatIconModule } from '@angular/material/icon';
import { RouterLink } from '@angular/router';
import { SidenavComponent } from '@lib/components/sidenav/sidenav.component';

@Component({
  selector: 'app-navbar',
  templateUrl: './navbar.component.html',
  styleUrl: './navbar.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: true,
  imports: [
    MatToolbarModule,
    MatButtonModule,
    MatSidenavModule,
    MatListModule,
    MatIconModule,
    AsyncPipe,
    RouterLink,
    SidenavComponent,
  ],
})
export class NavbarComponent {
  isHandset = input.required<boolean | null>();
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/sidenav/sidenav.component.html
<mat-sidenav-container class="sidenav-container">
  <mat-sidenav
    #drawer
    [attr.role]="isHandset() ? 'dialog' : 'navigation'"
    [mode]="isHandset() ? 'over' : 'side'"
    [opened]="!isHandset()"
    class="sidenav"
    fixedInViewport
  >
    <mat-toolbar>Menu</mat-toolbar>
    <mat-nav-list>
      <a mat-list-item routerLink="/">Recent</a>
      <a mat-list-item routerLink="/">Done</a>
      <a mat-list-item routerLink="/">Inbox</a>
    </mat-nav-list>
  </mat-sidenav>
  <mat-sidenav-content>
    <ng-content />
  </mat-sidenav-content>
</mat-sidenav-container>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/sidenav/sidenav.component.scss
.sidenav-container {
  height: 100vh;
}

.sidenav {
  width: 200px;
  height: calc(100vh - 4rem);
}

.sidenav .mat-toolbar {
  background: inherit;
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/sidenav/sidenav.component.ts
import {
  ChangeDetectionStrategy,
  Component,
  input,
  viewChild,
} from '@angular/core';
import { MatSidenav, MatSidenavModule } from '@angular/material/sidenav';
import { MatToolbar } from '@angular/material/toolbar';
import { MatListItem, MatNavList } from '@angular/material/list';
import { RouterLink } from '@angular/router';

@Component({
  selector: 'app-sidenav',
  standalone: true,
  imports: [MatSidenavModule, MatToolbar, MatNavList, MatListItem, RouterLink],
  templateUrl: './sidenav.component.html',
  styleUrl: './sidenav.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SidenavComponent {
  isHandset = input.required<boolean | null>();

  drawer = viewChild.required<MatSidenav>('drawer');

  async toggleDrawer() {
    await this.drawer().toggle();
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/guards/auth/auth.guard.ts
import { CanMatchFn, Route, Router, UrlSegment } from '@angular/router';
import { inject } from '@angular/core';
import { AuthService } from '@lib/services';

interface AuthGuardOptions {
  requiresAuthentication: boolean;
}

const defaultAuthGuardOptions = (): AuthGuardOptions => ({
  requiresAuthentication: true,
});

export const authGuard = (
  options: AuthGuardOptions = defaultAuthGuardOptions()
): CanMatchFn => {
  return (_: Route, segments: UrlSegment[]) => {
    const router = inject(Router);
    const authService = inject(AuthService);

    if (options.requiresAuthentication === authService.isAuthenticated())
      return true;

    return options.requiresAuthentication
      ? router.createUrlTree(['/auth/login'], {
          queryParams: {
            returnUrl: segments.map((s) => s.path).join('/'),
          },
        })
      : router.createUrlTree(['/']);
  };
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/guards/index.ts
export * from './auth/auth.guard';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interceptors/index.ts
export * from './jwt.interceptor';
export * from './server-error.interceptor';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interceptors/jwt.interceptor.ts
import { AuthService, TokenService } from '@lib/services';
import type { HttpInterceptorFn } from '@angular/common/http';
import { inject } from '@angular/core';

export const jwtInterceptor: HttpInterceptorFn = (req, next) => {
  const authService = inject(AuthService);
  const tokenService = inject(TokenService);

  if (authService.isAuthenticated()) {
    req = req.clone({
      setHeaders: {
        Authorization: `Bearer ${tokenService.accessToken}`,
      },
    });
  }

  return next(req);
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interceptors/server-error.interceptor.ts
import {
  HttpErrorResponse,
  HttpInterceptorFn,
  HttpStatusCode,
} from '@angular/common/http';
import { inject } from '@angular/core';
import { Router } from '@angular/router';
import { AuthService, TokenService } from '@lib/services';
import { catchError, switchMap, throwError, EMPTY } from 'rxjs';
import { ITokens } from '@myworkspace/data-models';

export const serverErrorInterceptor: HttpInterceptorFn = (req, next) => {
  const authSvc = inject(AuthService);
  const tokenSvc = inject(TokenService);
  const router = inject(Router);

  return next(req).pipe(
    catchError((error: HttpErrorResponse) => {
      if (error.status === HttpStatusCode.Unauthorized) {
        // Attempt to refresh token
        if (tokenSvc.refreshToken) {
          return authSvc.reAuthenticate(tokenSvc.refreshToken).pipe(
            switchMap((res: ITokens) => {
              const { accessToken } = tokenSvc;

              const modifiedReq = req.clone({
                setHeaders: {
                  Authorization: `Bearer ${accessToken}`,
                },
              });

              return next(modifiedReq);
            }),
            catchError((refreshError: HttpErrorResponse) => {
              if (refreshError.status === HttpStatusCode.Unauthorized)
                authSvc.logout();

              return throwError(() => refreshError);
            }),
          );
        } else {
          authSvc.logout();
          router.navigateByUrl('/auth/login');
          return EMPTY;
        }
      }

      return throwError(() => error);
    }),
  );
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interfaces/index.ts
export * from './response.interface';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interfaces/response.interface.ts
export interface IApiResponse<T> {
  message: string;
  data: T;
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/auth.service.ts
import { IAuthResponse, ITokens } from '@myworkspace/data-models';
import { inject, Injectable, signal } from '@angular/core';

import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { catchError, Observable, of, switchMap, throwError } from 'rxjs';
import { TokenService } from './token.service';
import { UserService } from './user.service';
import { IApiResponse } from '@lib/interfaces';
import { TokenType } from '@prisma/client';

@Injectable({
  providedIn: 'root',
})
export class AuthService {
  private readonly httpClient = inject(HttpClient);

  private readonly tokenSvc = inject(TokenService);
  private readonly userSvc = inject(UserService);

  readonly isAuthenticated = signal<boolean>(false);

  login(
    email: string,
    password: string,
  ): Observable<IApiResponse<IAuthResponse>> {
    return this.httpClient
      .post<IApiResponse<IAuthResponse>>(
        'http://localhost:3000/v1/auth/login',
        {
          email,
          password,
        },
      )
      .pipe(
        switchMap((res: IApiResponse<IAuthResponse>) => {
          const { tokens, user } = res.data;

          this.userSvc.user.set(user);
          this.tokenSvc.setTokens(tokens);
          this.isAuthenticated.set(true);
          return of(res);
        }),
        catchError((error) => {
          return throwError(() => error);
        }),
      );
  }

  reAuthenticate(refreshToken: string): Observable<ITokens> {
    return this.httpClient
      .post<ITokens>('http://localhost:3000/v1/auth/generate-new-tokens', {
        refreshToken,
      })
      .pipe(
        switchMap((res: ITokens) => {
          this.tokenSvc.setTokens(res);
          this.isAuthenticated.set(true);
          return of(res);
        }),
        catchError((error: HttpErrorResponse) => {
          this.isAuthenticated.set(false);
          this.tokenSvc.clear();
          return throwError(() => error);
        }),
      );
  }

  validateRefreshToken(refreshToken: string): Observable<IApiResponse<any>> {
    return this.httpClient
      .post<IApiResponse<any>>(
        'http://localhost:3000/v1/auth/check-refresh-token-validity',
        {
          refreshToken,
        },
      )
      .pipe(
        switchMap((res: IApiResponse<any>) => {
          if (res.data.user) {
            this.isAuthenticated.set(true);
            this.userSvc.user.set(res.data.user);
            // this.tokenSvc.setTokens(res.data.tokens);
            this.tokenSvc.setToken(
              res.data.accessToken.token,
              TokenType.ACCESS,
              res.data.accessToken.expires,
            );

            return of(res);
          }

          this.tokenSvc.clear();
          this.isAuthenticated.set(false);
          return throwError(() => new Error('Invalid refresh token'));
        }),
        catchError((error: HttpErrorResponse) => {
          this.tokenSvc.clear();
          return throwError(() => error);
        }),
      );
  }

  // eslint-disable-next-line @typescript-eslint/no-empty-function
  register(): void {}

  logout(): void {
    this.tokenSvc.clear();
    this.isAuthenticated.set(false);
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/index.ts
export * from './auth.service';
export * from './token.service';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/token.service.ts
import { inject, Injectable } from '@angular/core';
import { ITokens } from '@myworkspace/data-models';
import { TokenType } from '@prisma/client';
import { CookieService } from 'ngx-cookie-service';

@Injectable({
  providedIn: 'root',
})
export class TokenService {
  private readonly cookieSvc = inject(CookieService);

  get accessToken(): string {
    return this.cookieSvc.get('accessToken');
  }

  get refreshToken(): string {
    return this.cookieSvc.get('refreshToken');
  }

  setTokens(tokens: ITokens): void {
    this.setToken(tokens.access.token, TokenType.ACCESS, tokens.access.expires);

    this.setToken(
      tokens.refresh.token,
      TokenType.REFRESH,
      tokens.refresh.expires,
    );
  }

  setToken(token: string, type: TokenType, expires: number) {
    const cookieName = this.getCookieName(type);

    this.cookieSvc.set(cookieName, token, {
      expires: new Date(expires),
      sameSite: 'Strict',
      secure: false, // Set to true if using HTTPS
      path: '/',
    });
  }

  private getCookieName(type: TokenType): string {
    switch (type) {
      case TokenType.ACCESS:
        return 'accessToken';
      case TokenType.REFRESH:
        return 'refreshToken';
      default:
        throw new Error('Invalid token type');
    }
  }

  clear(): void {
    this.cookieSvc.delete('accessToken');
    this.cookieSvc.delete('refreshToken');
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/user.service.ts
import { Injectable, signal } from '@angular/core';
import { IUser } from '@myworkspace/data-models';

@Injectable({
  providedIn: 'root',
})
export class UserService {
  readonly user = signal<IUser | null>(null);
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/index.ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: 'login',
    title: 'Login',
    loadComponent: async () =>
      await import('./login/login.component').then((m) => m.LoginComponent),
  },
  {
    path: 'register',
    title: 'Register',
    loadComponent: async () =>
      await import('./register/register.component').then(
        (m) => m.RegisterComponent
      ),
  },
];


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/login/login.component.html
<div class="container">
  <form class="container__form" [formGroup]="loginForm" (ngSubmit)="onSignIn()">
    <h1 class="container__form__title">Sign in to Cando</h1>

    <mat-form-field>
      <mat-label>Email</mat-label>
      <input formControlName="email" matInput />
    </mat-form-field>

    <mat-form-field>
      <mat-label>Password</mat-label>
      <input formControlName="password" type="password" matInput />
    </mat-form-field>

    <button
      [disabled]="loginForm.invalid"
      (click)="onSignIn()"
      color="primary"
      mat-flat-button
      type="button"
    >
      Sign In
    </button>
  </form>

  <div class="container__info">
    <h1>Hello, Friend!</h1>
    <button
      [routerLink]="['/auth', 'register']"
      type="button"
      color="primary"
      mat-flat-button
    >
      Sign Up
    </button>
  </div>
</div>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/login/login.component.scss
:host {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100vw;
  height: 100vh;
  background: var(--main-color)
}

.container {
  display: flex;
  overflow: hidden;
  justify-content: space-between;
  width: 50rem;
  border-radius: 0.5rem;
  background: var(--white-color);

  &__info {
    display: flex;
    align-items: center;
    flex-direction: column;
    justify-content: center;
    padding: 2rem;
    color: var(--white-color);
    background: var(--secondary-color)
  }

  &__form {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    padding: 5rem;

    &__title {
      margin-top: 0;
      text-align: center;
      color: var(--main-color);
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/login/login.component.ts
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatButton } from '@angular/material/button';
import { MatFormField, MatLabel } from '@angular/material/form-field';
import { MatInput } from '@angular/material/input';
import { ActivatedRoute, Router, RouterLink } from '@angular/router';
import { AuthService } from '@lib/services';
import {
  FormControl,
  FormGroup,
  ReactiveFormsModule,
  Validators,
} from '@angular/forms';

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [
    CommonModule,
    MatButton,
    MatFormField,
    MatInput,
    MatLabel,
    RouterLink,
    ReactiveFormsModule,
  ],
  templateUrl: './login.component.html',
  styleUrl: './login.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class LoginComponent {
  private readonly authSvc = inject(AuthService);
  private readonly router = inject(Router);
  private readonly route = inject(ActivatedRoute);

  email = new FormControl<string>('', [Validators.required, Validators.email]);
  password = new FormControl<string>('', [Validators.required]);

  loginForm = new FormGroup({
    email: this.email,
    password: this.password,
  });

  onSignIn() {
    if (this.loginForm.invalid) return;

    const email = this.loginForm.value.email ?? '';
    const password = this.loginForm.value.password ?? '';

    this.authSvc.login(email, password).subscribe({
      next: (res) => {
        console.log('done');
        const url = this.route.snapshot.queryParams['returnUrl'] || '/';
        this.router.navigateByUrl(url);
      },
      error: (err) => {
        console.log('aici');
        console.error(err);
      },
      complete: () => {
        console.log('complete');
      },
    });
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/register/register.component.html
<div class="container">
  <div class="container__info">
    <h1>Welcome Back</h1>
    <button
      [routerLink]="['/auth', 'login']"
      color="primary"
      mat-flat-button
      type="button"
    >
      Sign In
    </button>
  </div>
  <form class="container__form">
    <h1 class="container__form__title">Create Account</h1>

    <mat-form-field>
      <mat-label>Name</mat-label>
      <input matInput />
    </mat-form-field>

    <mat-form-field>
      <mat-label>Email</mat-label>
      <input matInput />
    </mat-form-field>

    <mat-form-field>
      <mat-label>Password</mat-label>
      <input matInput />
    </mat-form-field>

    <button  (click)="onSignUp()" color="primary" mat-flat-button type="button">Sign Up</button>
  </form>
</div>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/register/register.component.scss
:host {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100vw;
  height: 100vh;
  background: var(--main-color)
}

.container {
  display: flex;
  overflow: hidden;
  justify-content: space-between;
  width: 50rem;
  border-radius: 0.5rem;
  background: var(--white-color);

  &__info {
    display: flex;
    align-items: center;
    flex-direction: column;
    justify-content: center;
    padding: 2rem;
    color: var(--white-color);
    background: var(--secondary-color)
  }

  &__form {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    padding: 3rem;

    &__title {
      text-align: center;
      color: var(--main-color);
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/register/register.component.ts
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatFormField, MatLabel } from '@angular/material/form-field';
import { MatInput } from '@angular/material/input';
import { MatButton } from '@angular/material/button';
import { RouterLink } from '@angular/router';
import { AuthService } from '@lib/services';

@Component({
  selector: 'app-register',
  standalone: true,
  imports: [
    CommonModule,
    MatFormField,
    MatInput,
    MatLabel,
    MatButton,
    RouterLink,
  ],
  templateUrl: './register.component.html',
  styleUrl: './register.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class RegisterComponent {
  private authSvc = inject(AuthService);

  onSignUp() {
    this.authSvc.register();
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/dashboard.component.html
<app-navbar [isHandset]="isHandset$ | async">
  <button (click)="testMethod()">test method</button>
</app-navbar>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/dashboard.component.scss


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/dashboard.component.ts
import { HttpClient } from '@angular/common/http';
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NavbarComponent } from '@lib/components';
import { BreakpointObserver, Breakpoints } from '@angular/cdk/layout';
import { map, shareReplay } from 'rxjs/operators';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-dashboard',
  standalone: true,
  imports: [CommonModule, NavbarComponent],
  templateUrl: './dashboard.component.html',
  styleUrl: './dashboard.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DashboardComponent {
  private readonly httpClient = inject(HttpClient);
  private readonly breakpointObserver = inject(BreakpointObserver);

  isHandset$: Observable<boolean> = this.breakpointObserver
    .observe(Breakpoints.Handset)
    .pipe(
      map((result) => result.matches),
      shareReplay(),
    );

  testMethod() {
    this.httpClient.post('http://localhost:3000/v1/task/test', {}).subscribe({
      next: (response) => console.log(response),
      error: (error) => {
        console.log('aici');
      },
      complete: () => console.info('complete'),
    });
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/index.ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: '',
    title: 'Dashboard',
    loadComponent: async () =>
      await import('./dashboard.component').then((m) => m.DashboardComponent),
  },
];


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>todo-app</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
  <body class="mat-typography">
    <app-root></app-root>
  </body>
</html>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/main.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, appConfig).catch((err) =>
  console.error(err)
);


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/styles.scss
// Custom Theming for Angular Material
// For more information: https://material.angular.io/guide/theming
@use '@angular/material' as mat;
// Plus imports for other components in your app.

// Include the common styles for Angular Material. We include this here so that you only
// have to load a single css file for Angular Material in your app.
// Be sure that you only ever include this mixin once!
@include mat.core();

// Define the palettes for your theme using the Material Design palettes available in palette.scss
// (imported above). For each palette, you can optionally specify a default, lighter, and darker
// hue. Available color palettes: https://material.io/design/color/
$todo-app-primary: mat.define-palette(mat.$indigo-palette);
$todo-app-accent: mat.define-palette(mat.$pink-palette, A200, A100, A400);

// The warn palette is optional (defaults to red).
$todo-app-warn: mat.define-palette(mat.$red-palette);

// Create the theme object. A theme consists of configurations for individual
// theming systems such as "color" or "typography".
$todo-app-theme: mat.define-light-theme((
  color: (
    primary: $todo-app-primary,
    accent: $todo-app-accent,
    warn: $todo-app-warn,
  ),
  typography: mat.define-typography-config(),
  density: 0
));

// Include theme styles for core and each component used in your app.
// Alternatively, you can import and @include the theme mixins for each component
// that you are using.
@include mat.all-component-themes($todo-app-theme);

/* You can add global styles to this file, and also import other style files */

:root {
  --main-color:#217981;
  --secondary-color: #38DDB6;
  --white-color: #faffff;
}

* {
  box-sizing: border-box;
}

html, body { height: 100%; }
body { font-family: Roboto, "Helvetica Neue", sans-serif; margin: 0; }


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/test-setup.ts
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
  testEnvironmentOptions: {
    errorOnUnknownElements: true,
    errorOnUnknownProperties: true,
  },
};
import 'jest-preset-angular/setup-jest';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/tsconfig.app.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "types": []
  },
  "files": ["src/main.ts"],
  "include": ["src/**/*.d.ts"],
  "exclude": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts"]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/tsconfig.editor.json
{
  "extends": "./tsconfig.json",
  "include": ["src/**/*.ts"],
  "compilerOptions": {},
  "exclude": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts"]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/tsconfig.json
{
  "compilerOptions": {
    "target": "es2022",
    "useDefineForClassFields": false,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "noImplicitOverride": true,
    "baseUrl": ".",
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "paths": {
      "@lib/*": ["src/app/lib/*"],
      "@pages/*": ["src/app/pages/*"],
      "@env/*": ["src/environments/*"],
      "@myworkspace/data-models": ["../../shared/data-models/src/index.ts"]
    },
    "noFallthroughCasesInSwitch": true
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.editor.json"
    },
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.spec.json"
    }
  ],
  "extends": "../../tsconfig.base.json",
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/tsconfig.spec.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "module": "commonjs",
    "target": "es2016",
    "types": ["jest", "node"]
  },
  "files": ["src/test-setup.ts"],
  "include": [
    "jest.config.ts",
    "src/**/*.test.ts",
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/.eslintrc.json
{
  "extends": ["../../.eslintrc.json"],
  "ignorePatterns": ["!**/*"],
  "overrides": [
    {
      "files": ["*.ts", "*.tsx", "*.js", "*.jsx"],
      "rules": {}
    },
    {
      "files": ["*.ts", "*.tsx"],
      "rules": {}
    },
    {
      "files": ["*.js", "*.jsx"],
      "rules": {}
    }
  ]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/jest.config.ts
/* eslint-disable */
export default {
  displayName: 'todo-server',
  preset: '../../jest.preset.js',
  testEnvironment: 'node',
  transform: {
    '^.+\\.[tj]s$': ['ts-jest', { tsconfig: '<rootDir>/tsconfig.spec.json' }],
  },
  moduleFileExtensions: ['ts', 'js', 'html'],
  coverageDirectory: '../../coverage/apps/todo-server',
};

File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/schema.prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String
  password  String   @db.VarChar(255)
  role      Role     @default(USER)
  tasks     Task[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Token     Token[]
}

model Token {
  id          Int       @id @default(autoincrement())
  token       String
  type        TokenType
  expires     DateTime
  blacklisted Boolean
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation(fields: [userId], references: [id])
  userId      String
}

model Task {
  id          String    @id @default(uuid())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  title       String    @db.VarChar(255)
  description String?
  dueDate     DateTime?
  completed   Boolean   @default(false)
  categoryId  String
  category    Category  @relation(fields: [categoryId], references: [id])
  userId      String
  user        User      @relation(fields: [userId], references: [id])
}

model Category {
  id    String @id @default(uuid())
  name  String @db.VarChar(255)
  tasks Task[]
}

enum Role {
  USER
  ADMIN
}

enum TokenType {
  ACCESS
  REFRESH
  RESET_PASSWORD
  VERIFY_EMAIL
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/project.json
{
  "name": "todo-server",
  "$schema": "../../node_modules/nx/schemas/project-schema.json",
  "sourceRoot": "apps/todo-server/src",
  "projectType": "application",
  "tags": [],
  "targets": {
    "build": {
      "executor": "@nx/esbuild:esbuild",
      "outputs": ["{options.outputPath}"],
      "defaultConfiguration": "production",
      "options": {
        "platform": "node",
        "outputPath": "dist/apps/todo-server",
        "format": ["cjs"],
        "bundle": false,
        "main": "apps/todo-server/src/main.ts",
        "tsConfig": "apps/todo-server/tsconfig.app.json",
        "assets": ["apps/todo-server/src/assets"],
        "generatePackageJson": true,
        "esbuildOptions": {
          "sourcemap": true,
          "outExtension": {
            ".js": ".js"
          }
        }
      },
      "configurations": {
        "development": {},
        "production": {
          "esbuildOptions": {
            "sourcemap": false,
            "outExtension": {
              ".js": ".js"
            }
          }
        }
      }
    },
    "serve": {
      "executor": "@nx/js:node",
      "defaultConfiguration": "development",
      "options": {
        "buildTarget": "todo-server:build"
      },
      "configurations": {
        "development": {
          "buildTarget": "todo-server:build:development"
        },
        "production": {
          "buildTarget": "todo-server:build:production"
        }
      }
    },
    "test": {
      "executor": "@nx/jest:jest",
      "outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
      "options": {
        "jestConfig": "apps/todo-server/jest.config.ts"
      }
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/app.ts
import express from 'express';

import compression from 'compression';
import helmet from 'helmet';
import { xss } from 'express-xss-sanitizer';
import cors from 'cors';
import passport from 'passport';
import httpStatus from 'http-status';

import routes from './routes/v1';

import { errorConverter, errorHandler } from './middlewares';

import ApiError from './utils/ApiError';

import { jwtStrategy } from './config/passport';

const app = express();

app.use(helmet());

app.use(express.json());

app.use(express.urlencoded({ extended: true }));

app.use(xss());

app.use(compression());

app.use(cors());

app.use(passport.initialize());
passport.use('jwt', jwtStrategy);

app.use('/v1', routes);

app.use((req, res, next) => {
  next(new ApiError(httpStatus.NOT_FOUND, 'Not found'));
});

app.use(errorConverter);

app.use(errorHandler);

export default app;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/assets/.gitkeep


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/client.ts
import { PrismaClient } from '@prisma/client';

// Singleton instance
let prisma: PrismaClient;

if (!prisma) {
  prisma = new PrismaClient();

  process.on('SIGTERM', async () => await prisma.$disconnect());
}

export default prisma;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/config/config.ts
import dotenv from 'dotenv';
import path from 'path';
import { z } from 'zod';
import { fromError } from 'zod-validation-error';

dotenv.config({ path: path.join(process.cwd(), '.env') });

const envVarsSchema = z.object({
  NODE_ENV: z
    .enum(['production', 'development', 'test'])
    .default('development'),
  PORT: z
    .string()
    .transform((x) => Number(x))
    .default('3000'),
  JWT_SECRET: z.string().min(1).describe('JWT secret key'),
  JWT_ACCESS_EXPIRATION_MINUTES: z
    .string()
    .transform((x) => Number(x))
    .default('30')
    .describe('minutes after which access tokens expire'),
  JWT_REFRESH_EXPIRATION_DAYS: z
    .string()
    .transform((x) => Number(x))
    .default('30')
    .describe('days after which refresh tokens expire'),
  JWT_RESET_PASSWORD_EXPIRATION_MINUTES: z
    .string()
    .transform((x) => Number(x))
    .default('10')
    .describe('minutes after which reset password token expires'),
  JWT_VERIFY_EMAIL_EXPIRATION_MINUTES: z
    .string()
    .transform((x) => Number(x))
    .default('10')
    .describe('minutes after which verify email token expires'),
});

// Parse and validate environment variables
const envVars = envVarsSchema.safeParse(process.env);

if (!envVars.success) {
  const validationError = fromError(envVars.error);
  console.error('❌ Invalid environment variables:', validationError.details);
  process.exit(1);
}

export default {
  env: envVars.data.NODE_ENV,
  port: envVars.data.PORT,
  jwt: {
    secret: envVars.data.JWT_SECRET,
    accessExpirationMinutes: envVars.data.JWT_ACCESS_EXPIRATION_MINUTES,
    refreshExpirationDays: envVars.data.JWT_REFRESH_EXPIRATION_DAYS,
    resetPasswordExpirationMinutes:
      envVars.data.JWT_RESET_PASSWORD_EXPIRATION_MINUTES,
    verifyEmailExpirationMinutes:
      envVars.data.JWT_VERIFY_EMAIL_EXPIRATION_MINUTES,
  },
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/config/passport.ts
import {
  ExtractJwt,
  Strategy as JwtStrategy,
  StrategyOptionsWithoutRequest,
  VerifyCallback,
} from 'passport-jwt';
import { TokenType } from '@prisma/client';
import prisma from '../client';
import config from './config';

const jwtOptions: StrategyOptionsWithoutRequest = {
  secretOrKey: config.jwt.secret,
  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
};

const jwtVerify: VerifyCallback = async (payload, done) => {
  try {
    if (payload.type !== TokenType.ACCESS) {
      throw new Error('Invalid token type');
    }

    const user = await prisma.user.findUnique({
      select: {
        id: true,
        email: true,
        name: true,
      },
      where: { id: payload.sub },
    });
    if (!user) {
      return done(null, false);
    }
    done(null, user);
  } catch (error) {
    done(error, false);
  }
};

export const jwtStrategy = new JwtStrategy(jwtOptions, jwtVerify);


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/config/roles.ts
import { Role } from '@prisma/client';

const allRoles = {
  [Role.USER]: [],
  [Role.ADMIN]: ['getUsers', 'manageUsers'],
};

export const roles = Object.keys(allRoles);
export const roleRights = new Map(Object.entries(allRoles));


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/controllers/auth.controller.ts
import { access } from 'fs';
import { Request, Response } from 'express';

import httpStatus from 'http-status';
import { z } from 'zod';

import { LoginSchema, RegistrationSchema } from '@myworkspace/data-models';

import { authService, tokenService, userService } from '../services';

import { catchAsync } from '../utils';
import { TokenType } from '@prisma/client';

export const register = catchAsync(async (req: Request, res: Response) => {
  RegistrationSchema.parse(req.body);

  const { email, name, password } = req.body as z.infer<
    typeof RegistrationSchema
  >;

  const user = await userService.createUser(email, name, password);

  return res.status(httpStatus.CREATED).json({
    message: 'User created successfully',
    data: { user },
  });
});

export const login = catchAsync(async (req: Request, res: Response) => {
  LoginSchema.parse(req.body);

  const { email, password } = req.body as z.infer<typeof LoginSchema>;

  const user = await authService.loginUserWithEmailAndPassword(email, password);
  const tokens = await tokenService.generateAuthTokens(user);

  return res.status(httpStatus.OK).json({
    message: 'Login successful',
    data: { user, tokens },
  });
});

export const generateNewTokens = catchAsync(
  async (req: Request, res: Response) => {
    const tokens = await authService.refreshAuth(req.body.refreshToken);

    return res.status(httpStatus.OK).json({
      message: 'Token refreshed successfully',
      data: tokens,
    });
  },
);

export const checkRefreshTokenValidity = catchAsync(
  async (req: Request, res: Response) => {
    const { refreshToken } = req.body;

    const refreshTokenData = await tokenService.verifyToken(
      refreshToken,
      TokenType.REFRESH,
    );

    if (!refreshTokenData) {
      return res.status(httpStatus.UNAUTHORIZED).json({
        message: 'Invalid refresh token',
      });
    }

    const user = await userService.getUserById(refreshTokenData.userId);

    if (!user) {
      return res.status(httpStatus.NOT_FOUND).json({
        message: 'User not found',
      });
    }

    const accessToken = await tokenService.generateAccessToken(user);

    return res.status(httpStatus.OK).json({
      message: 'Token validated successfully',
      data: { user, accessToken },
    });
  },
);


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/controllers/index.ts
export * as authController from './auth.controller';
export * as taskController from './task.controller';
export * as userController from './user.controller';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/controllers/task.controller.ts
import { Request, Response } from 'express';

export const test = (req: Request, res: Response) => {
  res.status(404).json({ message: 'Hello' });
};

// export const hello = (req: Request, res: Response) => {
//   res.status(200).json({ message: 'Hello API' });
// };


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/controllers/user.controller.ts
import { Request, Response } from 'express';
import httpStatus from 'http-status';
import { userService } from '../services';
import { catchAsync } from '../utils';

export const getUser = catchAsync(async (req: Request, res: Response) => {
  const { userId } = req.params;

  const user = await userService.getUserById(userId);

  if (!user) {
    return res.status(httpStatus.NOT_FOUND).json({
      message: 'User not found',
    });
  }

  return res.status(httpStatus.OK).json({
    message: 'User retrieved successfully',
    data: { user },
  });
});


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/main.ts
import { Server } from 'http';
import prisma from './client';
import app from './app';
import config from './config/config';

let server: Server;

prisma.$connect().then(() => {
  server = app.listen(config.port, () => {
    console.log(`Server is running on port ${config.port}`);
  });
});

const exitHandler = () => {
  if (server) {
    server.close(() => {
      console.log('Server closed');
      process.exit(1);
    });
  } else {
    process.exit(1);
  }
};

const unexpectedErrorHandler = (error: Error) => {
  console.log(error);
  exitHandler();
};

process.on('uncaughtException', unexpectedErrorHandler);
process.on('unhandledRejection', unexpectedErrorHandler);

process.on('SIGTERM', () => {
  console.log('SIGTERM received');
  if (server) {
    server.close();
  }
});


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/middlewares/auth.ts
import passport, { AuthenticateCallback } from 'passport';
import httpStatus from 'http-status';
import ApiError from '../utils/ApiError';
import { roleRights } from '../config/roles';
import { NextFunction, Request, Response } from 'express';
import { User } from '@prisma/client';

const verifyCallback: (
  req: Request,
  resolve: (value?: unknown) => void,
  reject: (reason?: unknown) => void,
  requiredRights: string[]
) => AuthenticateCallback =
  (req, resolve, reject, requiredRights) =>
  async (
    err: any,
    user?: User | false | null,
    info?: object | string | Array<string | undefined>
  ): Promise<void> => {
    if (err || info || !user) {
      return reject(
        new ApiError(httpStatus.UNAUTHORIZED, 'Please authenticate')
      );
    }
    req.user = user;

    if (requiredRights.length) {
      const userRights = roleRights.get(user.role) ?? [];
      const hasRequiredRights = requiredRights.every((requiredRight) =>
        userRights.includes(requiredRight)
      );
      if (!hasRequiredRights && req.params.userId !== user.id) {
        return reject(new ApiError(httpStatus.FORBIDDEN, 'Forbidden'));
      }
    }

    resolve();
  };

const auth =
  (...requiredRights: string[]) =>
  async (req: Request, res: Response, next: NextFunction) => {
    return new Promise((resolve, reject) => {
      passport.authenticate(
        'jwt',
        { session: false },
        verifyCallback(req, resolve, reject, requiredRights)
      )(req, res, next);
    })
      .then(() => next())
      .catch((err) => next(err));
  };

export default auth;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/middlewares/error.ts
import { ErrorRequestHandler, NextFunction, Request, Response } from 'express';
import { Prisma } from '@prisma/client';
import httpStatus from 'http-status';
import ApiError from '../utils/ApiError';
import { ZodError } from 'zod';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import { fromError } from 'zod-validation-error';

export const errorConverter: ErrorRequestHandler = (
  err: PrismaClientKnownRequestError | ZodError | ApiError,
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  let error = err;

  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    const statusCode = httpStatus.BAD_REQUEST;
    const message = error.message;
    error = new ApiError(statusCode, message, false);
  }

  if (error instanceof ZodError) {
    const validationError = fromError(error);
    const statusCode = httpStatus.BAD_REQUEST;
    const message = validationError.message;

    error = new ApiError(statusCode, message, false, validationError.details);
  }

  return next(error);
};

export const errorHandler: ErrorRequestHandler = (
  err: ApiError,
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  const { statusCode, message, errors } = err;

  const response = {
    statusCode,
    message,
    errors,
  };

  return res.status(statusCode).json(response);
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/middlewares/index.ts
export * from './error';
export * from './auth';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/routes/v1/auth.route.ts
import express from 'express';

import { authController } from '../../controllers';

const router = express.Router();

router.post('/register', authController.register);

router.post('/login', authController.login);

router.post('/generate-new-tokens', authController.generateNewTokens);
router.post(
  '/check-refresh-token-validity',
  authController.checkRefreshTokenValidity,
);

export default router;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/routes/v1/index.ts
import express from 'express';
import authRoute from './auth.route';
import taskRoute from './task.route';
import userRoute from './user.route';

const router = express.Router();

const defaultRoutes = [
  {
    path: '/auth',
    route: authRoute,
  },
  {
    path: '/task',
    route: taskRoute,
  },
  {
    path: '/user',
    route: userRoute,
  },
];

defaultRoutes.forEach((route) => {
  router.use(route.path, route.route);
});

export default router;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/routes/v1/task.route.ts
import express from 'express';

import { taskController } from '../../controllers';
import auth from '../../middlewares/auth';

const router = express.Router();

router.post('/test', auth(), taskController.test);

export default router;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/routes/v1/user.route.ts
import express from 'express';

import { userController } from '../../controllers';

import auth from '../../middlewares/auth';

const router = express.Router();

router.get('/:userId', auth(), userController.getUser);
// router.put('/:userId', auth(), userController.updateUser);
// router.delete('/:userId', auth(), userController.deleteUser);

export default router;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/services/auth.service.ts
import prisma from '../client';
import ApiError from '../utils/ApiError';
import { matchPassword } from '../utils';
import httpStatus from 'http-status';
import { exclude } from '../utils/exclude';
import { tokenService } from '.';
import { TokenType } from '@prisma/client';

export const loginUserWithEmailAndPassword = async (
  email: string,
  password: string,
) => {
  const user = await prisma.user.findUnique({
    where: {
      email,
    },
  });

  if (!user) throw new ApiError(httpStatus.NOT_FOUND, 'User not found');

  const isPasswordValid = await matchPassword(password, user.password);

  if (!isPasswordValid)
    throw new ApiError(httpStatus.UNAUTHORIZED, 'Invalid password');

  return exclude(user, ['password', 'createdAt', 'updatedAt']);
};

export const refreshAuth = async (refreshToken: string) => {
  try {
    const refreshTokenData = await tokenService.verifyToken(
      refreshToken,
      TokenType.REFRESH,
    );

    const { userId } = refreshTokenData;

    await prisma.token.delete({
      where: {
        id: refreshTokenData.id,
      },
    });

    return tokenService.generateAuthTokens({ id: userId });
  } catch (error) {
    throw new ApiError(httpStatus.UNAUTHORIZED, 'Please Authenticate');
  }
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/services/index.ts
export * as authService from './auth.service';
export * as tokenService from './token.service';
export * as userService from './user.service';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/services/token.service.ts
import { BaseUserSchema, ITokens } from '@myworkspace/data-models';
import z from 'zod';
import { TokenType } from '@prisma/client';
import jwt from 'jsonwebtoken';
import config from '../config/config.js';
import prisma from '../client.js';
import { access } from 'fs';

interface JwtPayload {
  sub: string;
  iat: number;
  exp: number;
  type: TokenType;
}

const generateToken = (
  userId: string,
  expires: Date,
  type: TokenType,
  secret = config.jwt.secret,
): string => {
  const payload: JwtPayload = {
    sub: userId,
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(expires.getTime() / 1000),
    type,
  };
  return jwt.sign(payload, secret);
};

const saveToken = async (
  userId: string,
  token: string,
  expires: Date,
  type: TokenType,
  blacklisted = false,
) => {
  const existingToken = await prisma.token.findFirst({
    where: {
      userId,
      type,
    },
  });

  if (existingToken) {
    await prisma.token.update({
      where: {
        id: existingToken.id,
      },
      data: {
        token,
        expires,
        blacklisted,
      },
    });

    return existingToken;
  }

  return await prisma.token.create({
    data: {
      userId,
      token,
      expires,
      type,
      blacklisted,
    },
  });
};

export const generateAccessToken = async (
  user: z.infer<typeof BaseUserSchema>,
) => {
  const { id: userId } = user;

  const expires = Date.now() + config.jwt.accessExpirationMinutes * 60 * 1000;

  const token = generateToken(userId, new Date(expires), TokenType.ACCESS);

  return { token, expires, type: TokenType.ACCESS };
};

export const generateAuthTokens = async (
  user: z.infer<typeof BaseUserSchema>,
): Promise<ITokens> => {
  const { id: userId } = user;

  const accessTokenExpires =
    Date.now() + config.jwt.accessExpirationMinutes * 60 * 1000;

  const refreshTokenExpires =
    Date.now() + config.jwt.refreshExpirationDays * 24 * 60 * 60 * 1000;

  const accessToken = generateToken(
    userId,
    new Date(accessTokenExpires),
    TokenType.ACCESS,
  );

  const refreshToken = generateToken(
    userId,
    new Date(refreshTokenExpires),
    TokenType.REFRESH,
  );

  await saveToken(
    userId,
    refreshToken,
    new Date(refreshTokenExpires),
    TokenType.REFRESH,
  );

  return {
    access: {
      token: accessToken,
      expires: accessTokenExpires,
      type: TokenType.ACCESS,
    },
    refresh: {
      token: refreshToken,
      expires: refreshTokenExpires,
      type: TokenType.REFRESH,
    },
  };
};

export const verifyToken = async (token: string, type: TokenType) => {
  const payload = jwt.verify(token, config.jwt.secret) as JwtPayload;

  const userId = payload.sub;

  if (payload.type !== type) throw new Error('Invalid token type');

  const tokenData = await prisma.token.findFirst({
    where: {
      userId,
      token,
      type,
      blacklisted: false,
    },
  });

  if (!tokenData) throw new Error('Token not found!');

  return tokenData;
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/services/user.service.ts
import prisma from '../client';
import ApiError from '../utils/ApiError';
import httpStatus from 'http-status';
import { encrypt, exclude } from '../utils';

export const createUser = async (
  email: string,
  name: string,
  password: string,
) => {
  const userExists = await prisma.user.findUnique({
    where: {
      email,
    },
  });

  if (userExists)
    throw new ApiError(httpStatus.CONFLICT, 'User already exists');

  const hashedPassword = await encrypt(password);

  const user = await prisma.user.create({
    data: {
      email,
      name,
      password: hashedPassword,
    },
  });

  return user;
};

export const getUserById = async (id: string) => {
  const user = await prisma.user.findUnique({
    where: {
      id,
    },
  });

  if (!user) throw new ApiError(httpStatus.NOT_FOUND, 'User not found');

  return exclude(user, ['password', 'createdAt', 'updatedAt']);
};

export const getUserByEmail = async (email: string) => {
  const user = await prisma.user.findUnique({
    where: {
      email,
    },
  });

  if (!user) throw new ApiError(httpStatus.NOT_FOUND, 'User not found');

  return exclude(user, ['password', 'createdAt', 'updatedAt']);
};

export const getUsers = async () => {
  const users = await prisma.user.findMany();
  return users;
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/ApiError.ts
class ApiError extends Error {
  statusCode: number;
  isOperational: boolean;
  errors: any[];

  constructor(
    statusCode: number,
    message?: string,
    isOperational = true,
    errors: any[] = []
  ) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.errors = errors;
  }
}

export default ApiError;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/catchAsync.ts
import { NextFunction, Request, RequestHandler, Response } from 'express';

export const catchAsync =
  (fn: RequestHandler) => (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/encryption.ts
import bcrypt from 'bcrypt';

export const encrypt = async (password: string) => {
  return await bcrypt.hash(password, 8);
};

export const matchPassword = (password: string, userPassword: string) => {
  return bcrypt.compare(password, userPassword);
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/exclude.ts
export const exclude = <Type, Key extends keyof Type>(
  obj: Type,
  keys: Key[]
): Omit<Type, Key> => {
  for (const key of keys) {
    delete obj[key];
  }
  return obj;
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/index.ts
export * from './ApiError';
export * from './catchAsync';
export * from './encryption';
export * from './exclude';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/tsconfig.app.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "module": "commonjs",
    "types": ["node"]
  },
  "exclude": ["jest.config.ts", "src/**/*.spec.ts", "src/**/*.test.ts"],
  "include": ["src/**/*.ts"]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.spec.json"
    }
  ],
  "compilerOptions": {
    "esModuleInterop": true
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/tsconfig.spec.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "module": "commonjs",
    "types": ["jest", "node"]
  },
  "include": [
    "jest.config.ts",
    "src/**/*.test.ts",
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}


