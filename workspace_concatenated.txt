File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/.eslintrc.json
{
  "extends": ["../../.eslintrc.json"],
  "ignorePatterns": ["!**/*"],
  "overrides": [
    {
      "files": ["*.ts"],
      "extends": [
        "plugin:@nx/angular",
        "plugin:@angular-eslint/template/process-inline-templates"
      ],
      "rules": {
        "@angular-eslint/directive-selector": [
          "error",
          {
            "type": "attribute",
            "prefix": "app",
            "style": "camelCase"
          }
        ],
        "@angular-eslint/component-selector": [
          "error",
          {
            "type": "element",
            "prefix": "app",
            "style": "kebab-case"
          }
        ]
      }
    },
    {
      "files": ["*.html"],
      "extends": ["plugin:@nx/angular-template"],
      "rules": {}
    }
  ]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/jest.config.ts
/* eslint-disable */
export default {
  displayName: 'todo-app',
  preset: '../../jest.preset.js',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
  coverageDirectory: '../../coverage/apps/todo-app',
  transform: {
    '^.+\\.(ts|mjs|js|html)$': [
      'jest-preset-angular',
      {
        tsconfig: '<rootDir>/tsconfig.spec.json',
        stringifyContentPathRegex: '\\.(html|svg)$',
      },
    ],
  },
  transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
  snapshotSerializers: [
    'jest-preset-angular/build/serializers/no-ng-attributes',
    'jest-preset-angular/build/serializers/ng-snapshot',
    'jest-preset-angular/build/serializers/html-comment',
  ],
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/project.json
{
  "name": "todo-app",
  "$schema": "../../node_modules/nx/schemas/project-schema.json",
  "projectType": "application",
  "prefix": "app",
  "sourceRoot": "apps/todo-app/src",
  "tags": [],
  "targets": {
    "build": {
      "executor": "@angular-devkit/build-angular:application",
      "outputs": ["{options.outputPath}"],
      "options": {
        "outputPath": "dist/apps/todo-app",
        "index": "apps/todo-app/src/index.html",
        "browser": "apps/todo-app/src/main.ts",
        "polyfills": ["zone.js"],
        "tsConfig": "apps/todo-app/tsconfig.app.json",
        "inlineStyleLanguage": "scss",
        "assets": ["apps/todo-app/src/favicon.ico", "apps/todo-app/src/assets"],
        "styles": [
          "apps/todo-app/src/styles.scss",
          "node_modules/ngx-toastr/toastr.css"
        ],
        "scripts": []
      },
      "configurations": {
        "production": {
          "budgets": [
            {
              "type": "initial",
              "maximumWarning": "500kb",
              "maximumError": "1mb"
            },
            {
              "type": "anyComponentStyle",
              "maximumWarning": "2kb",
              "maximumError": "4kb"
            }
          ],
          "outputHashing": "all"
        },
        "development": {
          "optimization": false,
          "extractLicenses": false,
          "sourceMap": true,
          "fileReplacements": [
            {
              "replace": "apps/todo-app/src/environments/environment.ts",
              "with": "apps/todo-app/src/environments/environment.development.ts"
            }
          ]
        }
      },
      "defaultConfiguration": "production"
    },
    "serve": {
      "executor": "@angular-devkit/build-angular:dev-server",
      "configurations": {
        "production": {
          "buildTarget": "todo-app:build:production"
        },
        "development": {
          "buildTarget": "todo-app:build:development"
        }
      },
      "defaultConfiguration": "development",
      "options": {
        "proxyConfig": "apps/todo-app/proxy.conf.json"
      }
    },
    "extract-i18n": {
      "executor": "@angular-devkit/build-angular:extract-i18n",
      "options": {
        "buildTarget": "todo-app:build"
      }
    },
    "lint": {
      "executor": "@nx/eslint:lint"
    },
    "test": {
      "executor": "@nx/jest:jest",
      "outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
      "options": {
        "jestConfig": "apps/todo-app/jest.config.ts"
      }
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/proxy.conf.json
{
  "/api": {
    "target": "http://localhost:3000",
    "secure": false
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/app.component.html
<router-outlet></router-outlet>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/app.component.scss


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/app.component.ts
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { RouterModule } from '@angular/router';
import { AuthService, TokenService } from '@lib/services';

@Component({
  standalone: true,
  imports: [RouterModule],
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrl: './app.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AppComponent {}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/app.config.ts
import { ApplicationConfig, importProvidersFrom } from '@angular/core';
import { provideRouter, withViewTransitions } from '@angular/router';
import { appRoutes } from './app.routes';
import { provideAnimationsAsync } from '@angular/platform-browser/animations/async';
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { jwtInterceptor, serverErrorInterceptor } from '@lib/interceptors';
import { provideToastr } from 'ngx-toastr';
import { AvatarModule } from 'ngx-avatars';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(
      appRoutes,
      withViewTransitions({ skipInitialTransition: true }),
    ),
    provideAnimationsAsync(),
    provideHttpClient(
      withInterceptors([jwtInterceptor, serverErrorInterceptor]),
    ),
    provideToastr(),
    importProvidersFrom(AvatarModule.forRoot()),
  ],
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/app.routes.ts
import { Route } from '@angular/router';
import { authGuard } from '@lib/guards';

export const appRoutes: Route[] = [
  {
    path: 'auth',
    loadChildren: async () => await import('@pages/auth').then((m) => m.routes),
    canMatch: [authGuard({ requiresAuthentication: false })],
  },

  {
    path: '',
    loadChildren: async () =>
      await import('@pages/dashboard').then((m) => m.routes),
    canMatch: [authGuard()],
  },
];


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/categories-list/categories-list.component.html
<mat-toolbar class="categories-list__toolbar">
  <span>Categories</span>
</mat-toolbar>

<mat-nav-list class="categories-list">
  @for (category of categoriesSvc.categories(); track category) {
    <a class="categories-list__item" mat-list-item>
      <div
        class="categories-list__item__color"
        [ngStyle]="{ 'background-color': category.color }"
      ></div>
      <span class="categories-list__item__text"> {{ category.name }}</span>
    </a>
  }

  <a class="categories-list__item" (click)="onCreateNewTag()" mat-list-item>
    <div class="categories-list__item__color"></div>
    <span class="categories-list__item__text categories-list__item__text--new"
      >New Tag</span
    >
  </a>
</mat-nav-list>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/categories-list/categories-list.component.scss
:host {
  display: block;
}

.categories-list {
  &__toolbar {
    background: inherit;
  }

  &__item {
    &__color {
      justify-self: center;
      background-color: rgba(var(--main-color));
      width: 0.75rem;
      height: 1.25rem;
    }

    &__text {
      grid-column: 3/5;

      &--new {
        opacity: 0.5;
      }
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/categories-list/categories-list.component.ts
import { MatListModule } from '@angular/material/list';
import {
  ChangeDetectionStrategy,
  Component,
  inject,
  OnInit,
} from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { CommonModule } from '@angular/common';
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatToolbar } from '@angular/material/toolbar';
import { CategoryService } from '@lib/services/category.service';
import { ToastrService } from 'ngx-toastr';

@Component({
  selector: 'app-categories-list',
  standalone: true,
  imports: [CommonModule, MatSidenavModule, MatListModule, MatToolbar],
  templateUrl: './categories-list.component.html',
  styleUrl: './categories-list.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CategoriesListComponent implements OnInit {
  private readonly dialog = inject(MatDialog);
  private readonly toastrSvc = inject(ToastrService);
  readonly categoriesSvc = inject(CategoryService);

  ngOnInit(): void {
    this.categoriesSvc.getCategories().subscribe({
      next: (res) => {
        this.toastrSvc.success(res.message);
      },
      error: (error: Error) => {
        this.toastrSvc.error(error.message);
      },
    });
  }

  async onCreateNewTag() {
    const { NewTagDialogComponent } = await import('@lib/components');

    this.dialog.open(NewTagDialogComponent, {
      disableClose: true,
    });
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/index.ts
export * from './categories-list/categories-list.component';
export * from './navbar/navbar.component';
export * from './new-tag-dialog/new-tag-dialog.component';
export * from './sidenav/sidenav.component';
export * from './task-card/task-card.component';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/navbar/navbar.component.html
<app-sidenav>
  <ng-content />
</app-sidenav>

<mat-toolbar color="primary">
  @if (breakpointSvc.isSmall() || breakpointSvc.isXSmall()) {
    <button
      (click)="onToggleSidenav()"
      type="button"
      aria-label="Toggle sidenav"
      mat-icon-button
    >
      <mat-icon aria-label="Side nav toggle icon">menu</mat-icon>
    </button>
  }
  <mat-menu #appMenu="matMenu">
    <ng-template matMenuContent>
      <button mat-menu-item>Profile</button>
      <button mat-menu-item>Settings</button>
      <button (click)="onLogout()" mat-menu-item>Log Out</button>
    </ng-template>
  </mat-menu>

  <div class="user__info" [matMenuTriggerFor]="appMenu">
    <ngx-avatars [name]="userSvc.user()?.name" size="35"></ngx-avatars>
    <span>
      {{ userSvc.user()?.name }}
    </span>
  </div>
</mat-toolbar>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/navbar/navbar.component.scss
.mat-toolbar.mat-primary {
  position: absolute;
  z-index: 1;
  bottom: 0;
}

.user {
  &__info {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 0.7rem;
    height: min-content;
    padding: 0.4rem;

    &:hover {
      cursor: pointer;
      background-color: #218a95;
      border-radius: 0.3rem;
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/navbar/navbar.component.ts
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { AsyncPipe } from '@angular/common';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatButtonModule } from '@angular/material/button';
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatListModule } from '@angular/material/list';
import { MatIconModule } from '@angular/material/icon';
import { RouterLink } from '@angular/router';
import { SidenavComponent } from '@lib/components/sidenav/sidenav.component';
import { MatMenuModule } from '@angular/material/menu';
import { BreakpointService } from '@lib/services/breakpoint.service';
import { SidenavService } from '@lib/services/sidenav.service';
import { AvatarModule } from 'ngx-avatars';
import { UserService } from '@lib/services/user.service';
import { AuthService } from '@lib/services';

@Component({
  selector: 'app-navbar',
  templateUrl: './navbar.component.html',
  styleUrl: './navbar.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: true,
  imports: [
    MatToolbarModule,
    MatButtonModule,
    MatSidenavModule,
    MatListModule,
    MatIconModule,
    AsyncPipe,
    RouterLink,
    SidenavComponent,
    MatMenuModule,
    AvatarModule,
  ],
})
export class NavbarComponent {
  readonly breakpointSvc = inject(BreakpointService);
  readonly userSvc = inject(UserService);
  readonly authSvc = inject(AuthService);

  private readonly sidenavSvc = inject(SidenavService);

  onToggleSidenav() {
    this.sidenavSvc.toggleSideNav();
  }

  onLogout() {
    this.authSvc.logout();
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/new-tag-dialog/new-tag-dialog.component.html
<div class="new-tag-dialog">
  <button
    class="new-tag-dialog__close-button"
    (click)="onClose()"
    mat-icon-button
  >
    <mat-icon>close</mat-icon>
  </button>

  <h2 class="new-tag-dialog__title">New Tag</h2>

  <div class="new-tag-dialog__form">
    <mat-form-field class="new-tag-dialog__form-field">
      <mat-label>Tag name</mat-label>
      <input class="new-tag-dialog__input" [formControl]="name" matInput />

      @if (name.hasError('too_small') && (name.dirty || name.touched)) {
        <mat-error> {{ name.getError('too_small') }} </mat-error>
      } @else if (name.hasError('too_big') && (name.dirty || name.touched)) {
        <mat-error> {{ name.getError('too_big') }} </mat-error>
      }
    </mat-form-field>

    <mat-form-field class="new-tag-dialog__form-field">
      <mat-label>Color</mat-label>
      <input [formControl]="color" readonly matInput />
      <ngx-colors
        class="new-tag-dialog__form-field__ngx-color"
        [formControl]="color"
        [format]="'hex'"
        [hideColorPicker]="true"
        (change)="onColorChange($event)"
        matSuffix
        ngx-colors-trigger
      ></ngx-colors>

      @if (color.hasError('invalid_string') && (color.dirty || color.touched)) {
        <mat-error> {{ color.getError('invalid_string') }} </mat-error>
      }
    </mat-form-field>

    <button
      class="new-tag-dialog__save-button"
      [disabled]="this.tagForm.invalid"
      (click)="onSave()"
      mat-raised-button
      color="primary"
    >
      Save
    </button>
  </div>
</div>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/new-tag-dialog/new-tag-dialog.component.scss
:host {
  display: block;
}

.new-tag-dialog {
  display: flex;
  position: relative;
  flex-direction: column;
  padding: 1rem;
  width: 400px;

  &__close-button {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
  }

  &__title {
    margin-top: unset;
  }

  &__form {
    display: flex;
    flex-direction: column;
  }

  &__form-field {
    width: 100%;

    &__ngx-color {
      display: block;
      width: 40px;
    }
  }

  &__input {
  }

  &__save-button {
    align-self: flex-end;
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/new-tag-dialog/new-tag-dialog.component.ts
import { ToastrService } from 'ngx-toastr';
import { MatIconModule } from '@angular/material/icon';
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { FormControl, FormGroup, ReactiveFormsModule } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatDialogRef } from '@angular/material/dialog';
import { NgxColorsModule } from 'ngx-colors';
import { zodValidator } from '@lib/validators/zod-validator.validator';
import { CreateCategorySchema } from '@myworkspace/data-models';
import { CategoryService } from '@lib/services/category.service';
import { HttpErrorResponse } from '@angular/common/http';

@Component({
  selector: 'app-new-tag-dialog',
  standalone: true,
  imports: [
    CommonModule,
    MatFormFieldModule,
    MatInputModule,
    ReactiveFormsModule,
    MatButtonModule,
    MatIconModule,
    NgxColorsModule,
  ],
  templateUrl: './new-tag-dialog.component.html',
  styleUrl: './new-tag-dialog.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class NewTagDialogComponent {
  private readonly dialogRef = inject(MatDialogRef<NewTagDialogComponent>);

  private readonly categoriesSvc = inject(CategoryService);
  private readonly toastrSvc = inject(ToastrService);

  name = new FormControl<string>('', [
    zodValidator(CreateCategorySchema.shape.name),
  ]);
  color = new FormControl<string>('', [
    zodValidator(CreateCategorySchema.shape.color),
  ]);

  tagForm = new FormGroup({
    name: this.name,
    color: this.color,
  });

  onClose() {
    this.dialogRef.close();
  }

  onSave() {
    if (this.tagForm.invalid) return;
    this.categoriesSvc
      .addCategory(this.name.value!, this.color.value!)
      .subscribe({
        next: (res) => {
          this.toastrSvc.success(res.message);
        },
        error: (error: Error) => {
          this.toastrSvc.error(error.message);
        },
        complete: () => {
          this.dialogRef.close();
        },
      });
  }

  onColorChange($event: string) {
    this.color.setValue($event);
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/sidenav/sidenav.component.html
<mat-sidenav-container class="sidenav-container">
  <mat-sidenav
    class="sidenav"
    #drawer
    [mode]="
      breakpointSvc.isSmall() || breakpointSvc.isXSmall() ? 'over' : 'side'
    "
    [attr.role]="
      breakpointSvc.isSmall() || breakpointSvc.isXSmall()
        ? 'dialog'
        : 'navigation'
    "
    [opened]="
      sidenavSvc.isSideNavOpen() ||
      !(breakpointSvc.isSmall() || breakpointSvc.isXSmall())
    "
    fixedInViewport
  >
    <mat-toolbar class="sidenav__toolbar">Menu</mat-toolbar>
    <mat-nav-list class="sidenav__list">
      <a
        class="sidenav__list__item"
        [routerLinkActiveOptions]="{ exact: true }"
        mat-list-item
        routerLinkActive="active-link"
        routerLink="/"
      >
        <mat-icon
          class="sidenav__list__item__icon"
          aria-hidden="false"
          aria-label="Example home icon"
          fontIcon="calendar_today"
        />
        <span class="sidenav__list__item__text">Recent</span>
      </a>
      <a
        class="sidenav__list__item"
        [routerLinkActiveOptions]="{ exact: true }"
        mat-list-item
        routerLinkActive="active-link"
        routerLink="/done"
        ><mat-icon
          class="sidenav__list__item__icon"
          aria-hidden="false"
          aria-label="Example home icon"
          fontIcon="event_available"
        /><span class="sidenav__list__item__text">Done</span></a
      >
      <a
        class="sidenav__list__item"
        [routerLinkActiveOptions]="{ exact: true }"
        routerLinkActive="active-link"
        routerLink="/inbox"
        mat-list-item
        ><mat-icon
          class="sidenav__list__item__icon"
          aria-hidden="false"
          aria-label="Example home icon"
          fontIcon="inbox"
        /><span class="sidenav__list__item__text">Inbox</span></a
      >
    </mat-nav-list>
    <app-categories-list class="sidenav__categories-list" />
  </mat-sidenav>

  <mat-sidenav-content class="sidenav-content">
    <ng-content />
  </mat-sidenav-content>
</mat-sidenav-container>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/sidenav/sidenav.component.scss
.sidenav-container {
  height: 100vh;

  .sidenav {
    width: 200px;
    height: calc(100vh - 4rem);

    &__toolbar {
      background: inherit;
    }

    .active-link {
      background: rgba(var(--secondary-color), 0.2);
    }

    &::ng-deep.mdc-list-item__primary-text {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      align-items: center;

      font-size: 1.1rem;
    }

    &__list {
      &__item {
        &__icon {
          justify-self: center;
          color: rgba(var(--main-color));
        }
        &__text {
          grid-column: 3 / 5;
        }
      }
    }

    &__categories-list {
      margin-top: 2rem;
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/sidenav/sidenav.component.ts
import { BreakpointService } from '@lib/services/breakpoint.service';
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatToolbar } from '@angular/material/toolbar';
import { MatListModule } from '@angular/material/list';
import { RouterModule } from '@angular/router';
import { MatIconModule } from '@angular/material/icon';
import { SidenavService } from '@lib/services/sidenav.service';
import { CategoriesListComponent } from '@lib/components';

@Component({
  selector: 'app-sidenav',
  standalone: true,
  templateUrl: './sidenav.component.html',
  styleUrl: './sidenav.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
  imports: [
    MatSidenavModule,
    MatToolbar,
    RouterModule,
    MatIconModule,
    CategoriesListComponent,
    MatListModule,
  ],
})
export class SidenavComponent {
  readonly breakpointSvc = inject(BreakpointService);
  readonly sidenavSvc = inject(SidenavService);
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/task-card/task-card.component.html
<mat-drawer-container class="task-card">
  <mat-drawer class="task-card__menu" #drawer mode="side">
    <div class="icon-group">
      <mat-icon class="icon-group__icon" fontSet="material-icons-outlined"
        >edit</mat-icon
      >

      <mat-icon class="icon-group__icon" fontSet="material-icons-outlined"
        >delete</mat-icon
      >

      <mat-icon class="icon-group__icon" fontSet="material-icons-outlined"
        >center_focus_strong</mat-icon
      >
    </div>
  </mat-drawer>
  <mat-drawer-content class="task-card__content">
    <div
      class="task-card__content__bar"
      #bar
      (clickOutside)="onCloseDrawer()"
      (click)="onOpenDrawer()"
    ></div>
    <input class="task-card__content__checkbox" type="checkbox" />

    <p class="task-card__content__date">14:15</p>
    <p class="task-card__content__title">Presentation title</p>
    <p class="task-card__content__description">Blah blah</p>
  </mat-drawer-content>
</mat-drawer-container>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/task-card/task-card.component.scss
.task-card {
  box-shadow: var(--shadow-xl);
  background-color: rgba(var(--white-color));

  .icon-group {
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    align-items: center;
    background-color: rgba(var(--main-color));
    height: 100%;

    &__icon {
      cursor: pointer;
      color: rgba(var(--secondary-color));
    }
  }

  &__menu {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    border: 0;
    background-color: var(--secondary-color);
    width: 3rem;
  }

  &__content {
    transition-duration: 400ms;
    transition-timing-function: cubic-bezier(0.25, 0.8, 0.25, 1);
    padding: 1rem 2rem 1rem;

    :has(mat-drawer.mat-drawer-opened) & {
      padding: 1rem;
    }

    &__bar {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      transition-duration: 400ms;
      transition-timing-function: cubic-bezier(0.25, 0.8, 0.25, 1);
      background-color: rgba(var(--main-color));
      width: 0.8rem;

      :has(mat-drawer.mat-drawer-opened) & {
        width: 0px;
      }
    }

    &__checkbox {
      position: absolute;
      top: 5px;
      right: 5px;
      cursor: pointer;
      background-color: green;
      width: 2rem;
      height: 2rem;
    }

    &__date {
    }

    &__title {
    }

    &__description {
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/task-card/task-card.component.ts
import { MatIconModule } from '@angular/material/icon';
import {
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ElementRef,
  HostListener,
  inject,
  input,
  NgZone,
  viewChild,
} from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatDrawer, MatSidenavModule } from '@angular/material/sidenav';
import { ITask } from '@myworkspace/data-models';
import { MatListModule } from '@angular/material/list';
import { MatButtonModule } from '@angular/material/button';
import { ClickOutside } from 'ngxtension/click-outside';

@Component({
  selector: 'app-task-card',
  standalone: true,
  imports: [
    CommonModule,
    MatSidenavModule,
    MatListModule,
    MatIconModule,
    MatButtonModule,
    ClickOutside,
  ],
  templateUrl: './task-card.component.html',
  styleUrl: './task-card.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class TaskCardComponent {
  private readonly ngzone = inject(NgZone);
  private readonly cdRef = inject(ChangeDetectorRef);

  private readonly drawer = viewChild.required<MatDrawer>('drawer');
  private readonly bar = viewChild.required<ElementRef<HTMLDivElement>>('bar');

  readonly task = input<ITask>();

  private hoverTimeout: ReturnType<typeof setTimeout> | undefined;

  @HostListener('mouseover', ['$event'])
  onMouseOver(event: MouseEvent) {
    if (this.bar().nativeElement === event.target) {
      this.ngzone.runOutsideAngular(() => {
        this.hoverTimeout = setTimeout(() => {
          this.drawer().open();
          this.cdRef.detectChanges();
        }, 500);
      });
    }
  }

  @HostListener('mouseleave', ['$event'])
  onMouseLeave(event: MouseEvent) {
    this.ngzone.runOutsideAngular(() => {
      clearTimeout(this.hoverTimeout);
      setTimeout(() => {
        this.drawer().close();
        this.cdRef.detectChanges();
      }, 1000);
    });
  }

  onOpenDrawer() {
    this.drawer().open();
    clearTimeout(this.hoverTimeout);
  }

  onCloseDrawer() {
    this.drawer().close();
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/guards/auth/auth.guard.ts
import { CanMatchFn, Route, Router, UrlSegment } from '@angular/router';
import { inject } from '@angular/core';
import { AuthService } from '@lib/services';
import { map } from 'rxjs';

interface AuthGuardOptions {
  requiresAuthentication: boolean;
}

const defaultAuthGuardOptions = (): AuthGuardOptions => ({
  requiresAuthentication: true,
});

export const authGuard = (
  options: AuthGuardOptions = defaultAuthGuardOptions(),
): CanMatchFn => {
  return (_: Route, segments: UrlSegment[]) => {
    const router = inject(Router);
    const authService = inject(AuthService);

    return authService.refreshToken().pipe(
      map((isAuthenticated: boolean) => {
        const currentUrl = segments.map((s) => s.path).join('/');
        const isAuthPage =
          currentUrl === 'auth/login' || currentUrl === 'auth/register';

        if (isAuthenticated && options.requiresAuthentication) {
          return true;
        }

        if (isAuthPage && !isAuthenticated) {
          return true;
        }

        if (options.requiresAuthentication && !isAuthenticated) {
          return router.createUrlTree(['/auth/login'], {
            queryParams: {
              returnUrl: currentUrl,
            },
          });
        }

        return router.createUrlTree(['/']);
      }),
    );
  };
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/guards/index.ts
export * from './auth/auth.guard';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interceptors/index.ts
export * from './jwt.interceptor';
export * from './server-error.interceptor';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interceptors/jwt.interceptor.ts
import { AuthService, TokenService } from '@lib/services';
import type { HttpInterceptorFn } from '@angular/common/http';
import { inject } from '@angular/core';

export const jwtInterceptor: HttpInterceptorFn = (req, next) => {
  const authService = inject(AuthService);
  const tokenService = inject(TokenService);

  if (authService.isAuthenticated() && tokenService.accessToken) {
    req = req.clone({
      setHeaders: {
        Authorization: `Bearer ${tokenService.accessToken}`,
      },
    });
  }

  return next(req);
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interceptors/server-error.interceptor.ts
import {
  HttpErrorResponse,
  HttpInterceptorFn,
  HttpRequest,
  HttpStatusCode,
} from '@angular/common/http';
import { inject } from '@angular/core';

import { AuthService, TokenService } from '@lib/services';
import { catchError, switchMap, throwError, EMPTY } from 'rxjs';

export const serverErrorInterceptor: HttpInterceptorFn = (req, next) => {
  const authSvc = inject(AuthService);
  const tokenSvc = inject(TokenService);

  const handleUnauthorizedError = (req: HttpRequest<unknown>) => {
    if (tokenSvc.refreshToken) {
      return authSvc.refreshToken().pipe(
        switchMap((res: boolean) => {
          if (res) {
            const { accessToken } = tokenSvc;

            const modifiedReq = req.clone({
              setHeaders: {
                Authorization: `Bearer ${accessToken}`,
              },
            });

            return next(modifiedReq);
          }

          // Refresh token failed
          authSvc.logout();

          return EMPTY;
        }),
      );
    }

    // No refresh token
    authSvc.logout();

    return EMPTY;
  };

  return next(req).pipe(
    catchError((error: HttpErrorResponse) => {
      switch (error.status) {
        case HttpStatusCode.Forbidden:
          authSvc.logout();
          return EMPTY;

        case HttpStatusCode.Unauthorized:
          return handleUnauthorizedError(req);

        case 0:
          return throwError(
            () =>
              new Error(
                'No internet connection. Please check your network and try again.',
              ),
          );

        default:
          return throwError(() => new Error(error.error.message));
      }
    }),
  );
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interfaces/index.ts
export * from './response.interface';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interfaces/response.interface.ts
export interface IApiResponse<T> {
  message: string;
  data: T;
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/auth.service.ts
import { environment } from './../../../environments/environment';
import {
  ILoginResponse,
  IRefreshTokenResponse,
  IRegisterResponse,
} from '@myworkspace/data-models';
import { inject, Injectable, signal } from '@angular/core';

import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { catchError, Observable, of, switchMap, throwError } from 'rxjs';
import { TokenService } from './token.service';
import { UserService } from './user.service';
import { IApiResponse } from '@lib/interfaces';
import { TokenType } from '@prisma/client';
import { Router } from '@angular/router';

@Injectable({
  providedIn: 'root',
})
export class AuthService {
  private readonly httpClient = inject(HttpClient);
  private readonly router = inject(Router);

  private readonly tokenSvc = inject(TokenService);
  private readonly userSvc = inject(UserService);

  readonly isAuthenticated = signal<boolean>(false);

  login(
    email: string,
    password: string,
  ): Observable<IApiResponse<ILoginResponse>> {
    return this.httpClient
      .post<IApiResponse<ILoginResponse>>(`${environment.apiUrl}/auth/login`, {
        email,
        password,
      })
      .pipe(
        switchMap((res: IApiResponse<ILoginResponse>) => {
          const { tokens, user } = res.data;

          this.userSvc.user.set(user);
          this.tokenSvc.setTokens(tokens);
          this.isAuthenticated.set(true);

          return of(res);
        }),
        catchError((error: HttpErrorResponse) => {
          return throwError(() => error);
        }),
      );
  }

  refreshToken(): Observable<boolean> {
    const { refreshToken } = this.tokenSvc;

    if (!refreshToken) {
      this.clearSession();
      return of(false);
    }

    if (this.isAuthenticated() && this.tokenSvc.accessToken) {
      return of(true);
    }

    return this.httpClient
      .post<IApiResponse<IRefreshTokenResponse>>(
        `${environment.apiUrl}/auth/refresh-token`,
        {
          refreshToken,
        },
      )
      .pipe(
        switchMap((res: IApiResponse<IRefreshTokenResponse>) => {
          if (res.data.user) {
            this.isAuthenticated.set(true);
            this.userSvc.user.set(res.data.user);
            this.tokenSvc.setToken(
              res.data.accessToken.token,
              TokenType.ACCESS,
              res.data.accessToken.expires,
            );

            return of(true);
          }

          this.clearSession();
          return of(false);
        }),
        catchError((error: HttpErrorResponse) => {
          this.clearSession();
          return of(false);
        }),
      );
  }

  register(
    name: string,
    email: string,
    password: string,
    confirmPassword: string,
  ) {
    return this.httpClient
      .post<IApiResponse<IRegisterResponse>>(
        `${environment.apiUrl}/auth/register`,
        {
          name,
          email,
          password,
          confirmPassword,
        },
      )
      .pipe(
        switchMap((res: IApiResponse<IRegisterResponse>) => {
          this.router.navigateByUrl('/auth/login');
          return of(res);
        }),
        catchError((error: HttpErrorResponse) => {
          return throwError(() => error);
        }),
      );
  }

  logout() {
    this.httpClient
      .post<IApiResponse<any>>(`${environment.apiUrl}/auth/logout`, {
        refreshToken: this.tokenSvc.refreshToken,
      })
      .pipe(
        switchMap((res: IApiResponse<any>) => {
          this.clearSession();
          this.router.navigateByUrl('/auth/login');
          return of(res);
        }),
        catchError((error: HttpErrorResponse) => {
          return throwError(() => error);
        }),
      )
      .subscribe();
  }

  private clearSession(): void {
    this.tokenSvc.clear();
    this.isAuthenticated.set(false);
    this.userSvc.user.set(null);
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/breakpoint.service.ts
import { computed, inject, Injectable } from '@angular/core';
import {
  BreakpointObserver,
  Breakpoints,
  BreakpointState,
} from '@angular/cdk/layout';
import {
  distinctUntilChanged,
  map,
  shareReplay,
  startWith,
} from 'rxjs/operators';

import { toSignal } from '@angular/core/rxjs-interop';

@Injectable({
  providedIn: 'root',
})
export class BreakpointService {
  private breakpointObserver = inject(BreakpointObserver);

  private readonly mediaQueryToBreakpointName: { [key: string]: string } = {
    [Breakpoints.XSmall]: 'XSmall',
    [Breakpoints.Small]: 'Small',
    [Breakpoints.Medium]: 'Medium',
    [Breakpoints.Large]: 'Large',
    [Breakpoints.XLarge]: 'XLarge',
    [Breakpoints.Handset]: 'Handset',
    [Breakpoints.Tablet]: 'Tablet',
    [Breakpoints.Web]: 'Web',
    [Breakpoints.HandsetPortrait]: 'HandsetPortrait',
    [Breakpoints.TabletPortrait]: 'TabletPortrait',
    [Breakpoints.WebPortrait]: 'WebPortrait',
    [Breakpoints.HandsetLandscape]: 'HandsetLandscape',
    [Breakpoints.TabletLandscape]: 'TabletLandscape',
    [Breakpoints.WebLandscape]: 'WebLandscape',
  };

  readonly isSmall = computed(() => this.breakpoints()?.['Small'] || false);
  readonly isXSmall = computed(() => this.breakpoints()?.['XSmall'] || false);
  readonly isMedium = computed(() => this.breakpoints()?.['Medium'] || false);
  readonly isLarge = computed(() => this.breakpoints()?.['Large'] || false);
  readonly isXLarge = computed(() => this.breakpoints()?.['XLarge'] || false);
  readonly isHandset = computed(() => this.breakpoints()?.['Handset'] || false);
  readonly isTablet = computed(() => this.breakpoints()?.['Tablet'] || false);
  readonly isWeb = computed(() => this.breakpoints()?.['Web'] || false);
  readonly isHandsetPortrait = computed(
    () => this.breakpoints()?.['HandsetPortrait'] || false,
  );
  readonly isTabletPortrait = computed(
    () => this.breakpoints()?.['TabletPortrait'] || false,
  );
  readonly isWebPortrait = computed(
    () => this.breakpoints()?.['WebPortrait'] || false,
  );
  readonly isHandsetLandscape = computed(
    () => this.breakpoints()?.['HandsetLandscape'] || false,
  );
  readonly isTabletLandscape = computed(
    () => this.breakpoints()?.['TabletLandscape'] || false,
  );
  readonly isWebLandscape = computed(
    () => this.breakpoints()?.['WebLandscape'] || false,
  );

  readonly breakpoints = toSignal(
    this.breakpointObserver.observe(Object.values(Breakpoints)).pipe(
      startWith({ matches: false, breakpoints: {} }),
      map((result: BreakpointState) => {
        const breakpointMatches: { [key: string]: boolean } = {};

        for (const query of Object.keys(result.breakpoints)) {
          const breakpointName = this.mediaQueryToBreakpointName[query];
          breakpointMatches[breakpointName] = result.breakpoints[query];
        }

        return breakpointMatches;
      }),
      distinctUntilChanged(),
      shareReplay(1),
    ),
  );
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/category.service.ts
import { HttpClient } from '@angular/common/http';
import { inject, Injectable, signal } from '@angular/core';
import { environment } from '@env/environment';
import { IApiResponse } from '@lib/interfaces';
import {
  ICategory,
  ICategoryResponse,
  ICreateCategoryResponse,
} from '@myworkspace/data-models';

import { catchError, Observable, of, switchMap, throwError } from 'rxjs';

@Injectable({
  providedIn: 'root',
})
export class CategoryService {
  private readonly HttpClient = inject(HttpClient);

  readonly categories = signal<ICategory[]>([]);

  getCategories(): Observable<IApiResponse<ICategoryResponse>> {
    return this.HttpClient.get<IApiResponse<ICategoryResponse>>(
      `${environment.apiUrl}/category`,
    ).pipe(
      switchMap((res) => {
        const { categories } = res.data;

        this.categories.set(categories);

        return of(res);
      }),
      catchError((error: Error) => {
        return throwError(() => error);
      }),
    );
  }

  addCategory(name: string, color: string) {
    return this.HttpClient.post<IApiResponse<ICreateCategoryResponse>>(
      `${environment.apiUrl}/category/create`,
      {
        name,
        color,
      },
    ).pipe(
      switchMap((res: IApiResponse<ICreateCategoryResponse>) => {
        const { category } = res.data;

        console.log(category);

        this.categories.update((categories) => [...categories, category]);
        return of(res);
      }),
      catchError((error: Error) => {
        return throwError(() => error);
      }),
    );
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/index.ts
export * from './auth.service';
export * from './token.service';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/sidenav.service.ts
import { Injectable, signal } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class SidenavService {
  readonly isSideNavOpen = signal(false);

  toggleSideNav(): void {
    this.isSideNavOpen.set(!this.isSideNavOpen());
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/token.service.ts
import { inject, Injectable } from '@angular/core';
import { ITokens } from '@myworkspace/data-models';
import { TokenType } from '@prisma/client';
import { CookieService } from 'ngx-cookie-service';

@Injectable({
  providedIn: 'root',
})
export class TokenService {
  private readonly cookieSvc = inject(CookieService);

  get accessToken(): string {
    return this.cookieSvc.get('accessToken');
  }

  get refreshToken(): string {
    return this.cookieSvc.get('refreshToken');
  }

  setTokens(tokens: ITokens): void {
    this.setToken(tokens.access.token, TokenType.ACCESS, tokens.access.expires);

    this.setToken(
      tokens.refresh.token,
      TokenType.REFRESH,
      tokens.refresh.expires,
    );
  }

  setToken(token: string, type: TokenType, expires: number): void {
    const cookieName = this.getCookieName(type);

    this.cookieSvc.set(cookieName, token, {
      expires: new Date(expires),
      sameSite: 'Strict',
      secure: false, // Set to true if using HTTPS
      path: '/',
    });
  }

  private getCookieName(type: TokenType): string {
    switch (type) {
      case TokenType.ACCESS:
        return 'accessToken';
      case TokenType.REFRESH:
        return 'refreshToken';
      default:
        throw new Error('Invalid token type');
    }
  }

  clear(): void {
    this.cookieSvc.delete('accessToken', '/');
    this.cookieSvc.delete('refreshToken', '/');
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/user.service.ts
import { Injectable, signal } from '@angular/core';
import { IUser } from '@myworkspace/data-models';

@Injectable({
  providedIn: 'root',
})
export class UserService {
  readonly user = signal<IUser | null>(null);
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/validators/match-validator.ts
import {
  ValidatorFn,
  AbstractControl,
  ValidationErrors,
  FormGroup,
} from '@angular/forms';

export function matchValidator(matchingControlName: string): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const group = control.parent as FormGroup;

    if (!group) {
      return null;
    }

    const matchingControl = group.controls[matchingControlName];
    const controlValue = control.value;
    const matchingControlValue = matchingControl.value;

    if (controlValue !== matchingControlValue) {
      return { noMatching: true };
    }

    return null;
  };
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/validators/zod-validator.validator.ts
import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';
import { fromError } from 'zod-validation-error';
import { ZodSchema } from 'zod';

export function zodValidator(schema: ZodSchema): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const result = schema.safeParse(control.value);
    if (result.success) {
      return null;
    }

    const zodErrors = fromError(result.error).details;

    const errors = zodErrors.reduce(
      (acc, error) => {
        acc[error.code] = error.message;
        return acc;
      },
      {} as Record<string, string>,
    );

    return errors;
  };
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/index.ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: 'login',
    title: 'Login',
    loadComponent: async () =>
      await import('./login/login.component').then((m) => m.LoginComponent),
  },
  {
    path: 'register',
    title: 'Register',
    loadComponent: async () =>
      await import('./register/register.component').then(
        (m) => m.RegisterComponent
      ),
  },
];


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/login/login.component.html
<div class="container">
  <form
    class="container__form"
    [formGroup]="loginForm"
    (keydown.enter)="onSignIn()"
  >
    <h1 class="container__form__title">Sign in to Cando</h1>

    <mat-form-field>
      <mat-label>Email</mat-label>
      <input [formControl]="email" matInput />
      @if (email.hasError('required') && (email.dirty || email.touched)) {
        <mat-error> Email is required </mat-error>
      } @else if (
        email.hasError('invalid_string') && (email.dirty || email.touched)
      ) {
        <mat-error> {{ email.getError('invalid_string') }} </mat-error>
      }
    </mat-form-field>

    <mat-form-field>
      <mat-label>Password</mat-label>
      <input [formControl]="password" type="password" matInput />
      @if (password.hasError('required') && (email.dirty || password.touched)) {
        <mat-error> Password is required </mat-error>
      } @else if (
        password.hasError('too_small') && (password.dirty || password.touched)
      ) {
        <mat-error> {{ password.getError('too_small') }} </mat-error>
      }
    </mat-form-field>

    <button
      [disabled]="loginForm.invalid || isSubmitted()"
      (click)="onSignIn()"
      color="primary"
      mat-flat-button
      type="button"
    >
      Sign In
    </button>
  </form>

  <div class="container__info">
    <h1>Hello, Friend!</h1>
    <button
      [routerLink]="['/auth', 'register']"
      type="button"
      color="primary"
      mat-flat-button
    >
      Sign Up
    </button>
  </div>
</div>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/login/login.component.scss
:host {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100vw;
  height: 100vh;
  background: rgba(var(--main-color));
}

.container {
  display: flex;
  overflow: hidden;
  justify-content: space-between;
  width: 50rem;
  border-radius: 0.5rem;
  background: rgba(var(--white-color));

  &__info {
    display: flex;
    align-items: center;
    flex-direction: column;
    justify-content: center;
    padding: 2rem;
    color: rgba(var(--white-color));
    background: rgba(var(--secondary-color));
  }

  &__form {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    padding: 5rem;

    &__title {
      margin-top: 0;
      text-align: center;
      color: rgba(var(--main-color));
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/login/login.component.ts
import {
  ChangeDetectionStrategy,
  Component,
  inject,
  signal,
  Signal,
} from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatButtonModule } from '@angular/material/button';
import { MatFormField, MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { Router, RouterLink } from '@angular/router';
import { AuthService } from '@lib/services';
import {
  FormControl,
  FormGroup,
  FormsModule,
  ReactiveFormsModule,
  Validators,
} from '@angular/forms';
import { zodValidator } from '@lib/validators/zod-validator.validator';
import { LoginSchema } from '@myworkspace/data-models';
import { injectQueryParams } from 'ngxtension/inject-query-params';
import { ToastrService } from 'ngx-toastr';
import { HttpErrorResponse } from '@angular/common/http';

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [
    CommonModule,
    MatButtonModule,
    MatFormField,
    RouterLink,
    ReactiveFormsModule,
    FormsModule,
    MatFormFieldModule,
    MatInputModule,
  ],
  templateUrl: './login.component.html',
  styleUrl: './login.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class LoginComponent {
  private readonly authSvc = inject(AuthService);
  private readonly toastrSvc = inject(ToastrService);

  private readonly router = inject(Router);

  protected isSubmitted = signal(false);

  readonly returnUrl = injectQueryParams('returnUrl', {
    initialValue: '/',
  }) as Signal<string>;

  email = new FormControl<string>('', [
    zodValidator(LoginSchema.shape.email),
    Validators.required,
  ]);
  password = new FormControl<string>('', [
    zodValidator(LoginSchema.shape.password),
    Validators.required,
  ]);

  loginForm = new FormGroup({
    email: this.email,
    password: this.password,
  });

  onSignIn(): void {
    if (this.loginForm.invalid) return;

    this.isSubmitted.set(true);

    this.authSvc
      .login(this.email.value as string, this.password.value as string)
      .subscribe({
        complete: () => {
          this.router.navigateByUrl(this.returnUrl());
          this.toastrSvc.success('Logged in successfully');
          this.isSubmitted.set(false);
        },
        error: (error: HttpErrorResponse | Error) => {
          const errorMessage =
            error instanceof HttpErrorResponse
              ? error.error.message
              : error.message;

          this.toastrSvc.error(errorMessage);
          this.isSubmitted.set(false);
        },
      });
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/register/register.component.html
<div class="container">
  <div class="container__info">
    <h1>Welcome Back</h1>
    <button
      [routerLink]="['/auth', 'login']"
      color="primary"
      mat-flat-button
      type="button"
    >
      Sign In
    </button>
  </div>
  <form class="container__form">
    <h1 class="container__form__title">Create Account</h1>

    <mat-form-field>
      <mat-label>Name</mat-label>
      <input [formControl]="name" matInput />
      @if (name.hasError('required') && (name.dirty || name.touched)) {
        <mat-error> Name is required </mat-error>
      } @else if (name.hasError('too_small') && (name.dirty || name.touched)) {
        <mat-error> {{ name.getError('too_small') }} </mat-error>
      }
    </mat-form-field>

    <mat-form-field>
      <mat-label>Email</mat-label>
      <input [formControl]="email" matInput />
      @if (email.hasError('required') && (email.dirty || email.touched)) {
        <mat-error> Email is required </mat-error>
      } @else if (
        email.hasError('too_small') && (email.dirty || email.touched)
      ) {
        <mat-error> {{ email.getError('too_small') }} </mat-error>
      }
    </mat-form-field>

    <mat-form-field>
      <mat-label>Password</mat-label>
      <input [formControl]="password" matInput />
      @if (
        password.hasError('required') && (password.dirty || password.touched)
      ) {
        <mat-error> Password is required </mat-error>
      } @else if (
        password.hasError('invalid_string') &&
        (password.dirty || password.touched)
      ) {
        <mat-error> {{ password.getError('invalid_string') }} </mat-error>
      }
    </mat-form-field>

    <mat-form-field>
      <mat-label>Confirm Password</mat-label>
      <input [formControl]="confirmPassword" matInput />
      @if (
        confirmPassword.hasError('required') &&
        (confirmPassword.dirty || confirmPassword.touched)
      ) {
        <mat-error> Confirm password is required </mat-error>
      } @else if (
        confirmPassword.hasError('too_small') &&
        (confirmPassword.dirty || confirmPassword.touched)
      ) {
        <mat-error>
          {{ confirmPassword.getError('too_small') }}
        </mat-error>
      } @else if (
        confirmPassword.hasError('noMatching') &&
        (confirmPassword.dirty || confirmPassword.touched)
      ) {
        <mat-error> Passwords do not match </mat-error>
      }
    </mat-form-field>

    <button
      [disabled]="registerForm.invalid"
      (click)="onSignUp()"
      color="primary"
      mat-flat-button
      type="button"
    >
      Sign Up
    </button>
  </form>
</div>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/register/register.component.scss
:host {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100vw;
  height: 100vh;
  background: rgba(var(--main-color));
}

.container {
  display: flex;
  overflow: hidden;
  justify-content: space-between;
  width: 50rem;
  border-radius: 0.5rem;
  background: rgba(var(--white-color));

  &__info {
    display: flex;
    align-items: center;
    flex-direction: column;
    justify-content: center;
    padding: 2rem;
    color: rgba(var(--white-color));
    background: rgba(var(--secondary-color));
  }

  &__form {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    padding: 3rem;

    &__title {
      text-align: center;
      color: rgba(var(--main-color));
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/register/register.component.ts
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatError, MatFormField, MatLabel } from '@angular/material/form-field';
import { MatInput } from '@angular/material/input';
import { MatButton } from '@angular/material/button';
import { RouterLink } from '@angular/router';
import { AuthService } from '@lib/services';
import {
  FormControl,
  FormGroup,
  ReactiveFormsModule,
  Validators,
} from '@angular/forms';
import { zodValidator } from '@lib/validators/zod-validator.validator';
import { BaseRegisterSchema } from '@myworkspace/data-models';
import { matchValidator } from '@lib/validators/match-validator';
import { HttpErrorResponse } from '@angular/common/http';
import { ToastrService } from 'ngx-toastr';

@Component({
  selector: 'app-register',
  standalone: true,
  imports: [
    CommonModule,
    MatFormField,
    MatInput,
    MatLabel,
    MatButton,
    RouterLink,
    ReactiveFormsModule,
    MatError,
  ],
  templateUrl: './register.component.html',
  styleUrl: './register.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class RegisterComponent {
  private authSvc = inject(AuthService);
  private toastrSvc = inject(ToastrService);

  name = new FormControl('', [
    zodValidator(BaseRegisterSchema.shape.name),
    Validators.required,
  ]);
  email = new FormControl('', [
    zodValidator(BaseRegisterSchema.shape.email),
    Validators.required,
  ]);
  password = new FormControl('', [
    zodValidator(BaseRegisterSchema.shape.password),
    Validators.required,
  ]);
  confirmPassword = new FormControl('', [
    matchValidator('password'),
    Validators.required,
  ]);

  registerForm = new FormGroup({
    name: this.name,
    email: this.email,
    password: this.password,
    confirmPassword: this.confirmPassword,
  });

  onSignUp() {
    if (this.registerForm.invalid) {
      return;
    }

    this.authSvc
      .register(
        this.name.value as string,
        this.email.value as string,
        this.password.value as string,
        this.confirmPassword.value as string,
      )
      .subscribe({
        complete: () => {
          this.toastrSvc.success('Registration successful!');
        },
        error: (error: HttpErrorResponse) => {
          this.toastrSvc.error(error.error.message);
        },
      });
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/dashboard.component.html
<app-navbar>
  <router-outlet></router-outlet>
</app-navbar>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/dashboard.component.scss


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/dashboard.component.ts
import { ChangeDetectionStrategy, Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NavbarComponent } from '@lib/components';

import { RouterOutlet } from '@angular/router';

@Component({
  selector: 'app-dashboard',
  standalone: true,
  imports: [CommonModule, NavbarComponent, RouterOutlet],
  templateUrl: './dashboard.component.html',
  styleUrl: './dashboard.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DashboardComponent {}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/done/done.component.html
<p>done works!</p>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/done/done.component.scss


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/done/done.component.ts
import { ChangeDetectionStrategy, Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-done',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './done.component.html',
  styleUrl: './done.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DoneComponent {}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/inbox/inbox.component.html
<p>inbox works!</p>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/inbox/inbox.component.scss


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/inbox/inbox.component.ts
import { ChangeDetectionStrategy, Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-inbox',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './inbox.component.html',
  styleUrl: './inbox.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class InboxComponent {}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/index.ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: '',
    title: 'Dashboard',
    loadComponent: async () =>
      await import('@pages/dashboard/dashboard.component').then(
        (m) => m.DashboardComponent,
      ),
    children: [
      {
        path: '',
        title: 'Recent Tasks',
        loadComponent: async () =>
          await import('./recent/recent.component').then(
            (m) => m.RecentComponent,
          ),
      },
      {
        path: 'done',
        title: 'Done Tasks',
        loadComponent: async () =>
          await import('./done/done.component').then((m) => m.DoneComponent),
      },
      {
        path: 'inbox',
        title: 'Inbox',
        loadComponent: async () =>
          await import('./inbox/inbox.component').then((m) => m.InboxComponent),
      },
    ],
  },
];


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/recent/recent.component.html
<div class="container">
  <div class="container__section">
    <h1 class="container__section-title">Today</h1>
    <mat-chip-set aria-label="Fish selection">
      <mat-chip><span>One fish</span></mat-chip>
      <mat-chip>Two fish</mat-chip>
      <mat-chip>Three fish</mat-chip>
      <mat-chip>Four fish</mat-chip>
      <mat-chip>Five fish</mat-chip>
      <mat-chip>Six fish</mat-chip>
      <mat-chip>Seven fish</mat-chip>
      <mat-chip>Eight fish</mat-chip>
      <mat-chip>Nine fish</mat-chip>
      <mat-chip>Ten fish</mat-chip>
      <mat-chip>Eleven fish</mat-chip>
    </mat-chip-set>

    <div class="container__section__task-list">
      <app-task-card />
      <app-task-card />
    </div>
  </div>

  <div class="container__section">
    <h1 class="container__section-title">Future</h1>
  </div>
</div>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/recent/recent.component.scss
:host {
  display: block;
  background-color: rgba(var(--secondary-color), 0.05);
  padding: 3rem;
  width: 100%;
  height: 100%;
}

.container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
  height: 100%;
  grid-gap: 3rem;

  &__section {
    &-title {
      margin: 0;
      color: rgba(var(--main-color));
    }

    mat-chip-set {
      ::ng-deep .mdc-evolution-chip-set__chips {
        flex-wrap: nowrap;
        overflow-x: auto;
        scrollbar-width: thin;
      }
    }

    &__task-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-top: 1rem;
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/recent/recent.component.ts
import { ChangeDetectionStrategy, Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatChipsModule } from '@angular/material/chips';
import { MatSidenavModule } from '@angular/material/sidenav';
import { TaskCardComponent } from '@lib/components';

@Component({
  selector: 'app-recent',
  standalone: true,
  templateUrl: './recent.component.html',
  styleUrl: './recent.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
  imports: [CommonModule, MatChipsModule, MatSidenavModule, TaskCardComponent],
})
export class RecentComponent {}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/assets/.gitkeep


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/environments/environment.development.ts
export const environment = {
  production: false,
  apiUrl: 'http://localhost:3000/v1',
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/environments/environment.ts
export const environment = {
  production: true,
  apiUrl: 'http://localhost:3000/v1',
};

File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>todo-app</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css?family=Material+Icons|Material+Icons+Outlined|Material+Icons+Two+Tone|Material+Icons+Round|Material+Icons+Sharp"
      rel="stylesheet"
    />
  </head>
  <body class="mat-typography">
    <app-root></app-root>
  </body>
</html>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/main.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, appConfig).catch((err) =>
  console.error(err)
);


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/styles.scss
@use '@angular/material' as mat;

@include mat.core();

$main-palette: (
  50: #e4eff0,
  100: #bcd7d9,
  200: #90bcc0,
  300: #64a1a7,
  400: #428d94,
  500: #217981,
  600: #1d7179,
  700: #18666e,
  800: #145c64,
  900: #0b4951,
  A100: #87efff,
  A200: #54e9ff,
  A400: #21e2ff,
  A700: #08dfff,
  contrast: (
    50: #000000,
    100: #000000,
    200: #000000,
    300: #000000,
    400: #ffffff,
    500: #ffffff,
    600: #ffffff,
    700: #ffffff,
    800: #ffffff,
    900: #ffffff,
    A100: #000000,
    A200: #000000,
    A400: #000000,
    A700: #000000,
  ),
);

$secondary-palette: (
  50: #e7fbf0,
  100: #c3f5db,
  200: #9ceec3,
  300: #74e7aa,
  400: #56e298,
  500: #38dd86,
  600: #32d97e,
  700: #2bd473,
  800: #24cf69,
  900: #17c756,
  A100: #f9fffb,
  A200: #c6ffd8,
  A400: #93ffb6,
  A700: #7affa5,
  contrast: (
    50: #000000,
    100: #000000,
    200: #000000,
    300: #000000,
    400: #000000,
    500: #000000,
    600: #000000,
    700: #000000,
    800: #000000,
    900: #000000,
    A100: #000000,
    A200: #000000,
    A400: #000000,
    A700: #000000,
  ),
);

$todo-app-primary: mat.define-palette($main-palette);
$todo-app-accent: mat.define-palette($secondary-palette);
$todo-app-warn: mat.define-palette(mat.$red-palette);

$todo-app-theme: mat.define-light-theme(
  (
    color: (
      primary: $todo-app-primary,
      accent: $todo-app-accent,
      warn: $todo-app-warn,
    ),
    typography: mat.define-typography-config(),
    density: 0,
  )
);

@include mat.all-component-themes($todo-app-theme);

/* You can add global styles to this file, and also import other style files */

:root {
  --main-color: 26, 121, 130;
  --secondary-color: 41, 222, 182;
  --white-color: 249, 255, 254;

  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1),
    0 4px 6px -4px rgb(0 0 0 / 0.1);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1),
    0 8px 10px -6px rgb(0 0 0 / 0.1);
  --shadow-2xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);
  --shadow-inner: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);
  --shadow-none: 0 0 #0000;
}

* {
  box-sizing: border-box;
}

html,
body {
  height: 100%;
}
body {
  font-family: Roboto, 'Helvetica Neue', sans-serif;
  margin: 0;
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/test-setup.ts
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
  testEnvironmentOptions: {
    errorOnUnknownElements: true,
    errorOnUnknownProperties: true,
  },
};
import 'jest-preset-angular/setup-jest';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/tsconfig.app.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "types": []
  },
  "files": ["src/main.ts"],
  "include": ["src/**/*.d.ts"],
  "exclude": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts"]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/tsconfig.editor.json
{
  "extends": "./tsconfig.json",
  "include": ["src/**/*.ts"],
  "compilerOptions": {},
  "exclude": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts"]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/tsconfig.json
{
  "compilerOptions": {
    "target": "es2022",
    "useDefineForClassFields": false,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "noImplicitOverride": true,
    "baseUrl": ".",
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "paths": {
      "@lib/*": ["src/app/lib/*"],
      "@pages/*": ["src/app/pages/*"],
      "@env/*": ["src/environments/*"],
      "@myworkspace/data-models": ["../../shared/data-models/src/index.ts"]
    },
    "noFallthroughCasesInSwitch": true
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.editor.json"
    },
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.spec.json"
    }
  ],
  "extends": "../../tsconfig.base.json",
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/tsconfig.spec.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "module": "commonjs",
    "target": "es2016",
    "types": ["jest", "node"]
  },
  "files": ["src/test-setup.ts"],
  "include": [
    "jest.config.ts",
    "src/**/*.test.ts",
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/.eslintrc.json
{
  "extends": ["../../.eslintrc.json"],
  "ignorePatterns": ["!**/*"],
  "overrides": [
    {
      "files": ["*.ts", "*.tsx", "*.js", "*.jsx"],
      "rules": {}
    },
    {
      "files": ["*.ts", "*.tsx"],
      "rules": {}
    },
    {
      "files": ["*.js", "*.jsx"],
      "rules": {}
    }
  ]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/jest.config.ts
/* eslint-disable */
export default {
  displayName: 'todo-server',
  preset: '../../jest.preset.js',
  testEnvironment: 'node',
  transform: {
    '^.+\\.[tj]s$': ['ts-jest', { tsconfig: '<rootDir>/tsconfig.spec.json' }],
  },
  moduleFileExtensions: ['ts', 'js', 'html'],
  coverageDirectory: '../../coverage/apps/todo-server',
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240419080108_init/migration.sql
-- CreateTable
CREATE TABLE "Post" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "content" TEXT,
    "published" BOOLEAN NOT NULL DEFAULT false,
    "authorId" INTEGER NOT NULL,

    CONSTRAINT "Post_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Profile" (
    "id" SERIAL NOT NULL,
    "bio" TEXT,
    "userId" INTEGER NOT NULL,

    CONSTRAINT "Profile_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Profile_userId_key" ON "Profile"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- AddForeignKey
ALTER TABLE "Post" ADD CONSTRAINT "Post_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Profile" ADD CONSTRAINT "Profile_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240419083352_init/migration.sql
/*
  Warnings:

  - The primary key for the `User` table will be changed. If it partially fails, the table could be left without primary key constraint.
  - You are about to drop the `Post` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `Profile` table. If the table is not empty, all the data it contains will be lost.
  - Added the required column `password` to the `User` table without a default value. This is not possible if the table is not empty.
  - Added the required column `updatedAt` to the `User` table without a default value. This is not possible if the table is not empty.

*/
-- DropForeignKey
ALTER TABLE "Post" DROP CONSTRAINT "Post_authorId_fkey";

-- DropForeignKey
ALTER TABLE "Profile" DROP CONSTRAINT "Profile_userId_fkey";

-- AlterTable
ALTER TABLE "User" DROP CONSTRAINT "User_pkey",
ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "password" VARCHAR(255) NOT NULL,
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL,
ALTER COLUMN "id" DROP DEFAULT,
ALTER COLUMN "id" SET DATA TYPE TEXT,
ADD CONSTRAINT "User_pkey" PRIMARY KEY ("id");
DROP SEQUENCE "User_id_seq";

-- DropTable
DROP TABLE "Post";

-- DropTable
DROP TABLE "Profile";

-- CreateTable
CREATE TABLE "Task" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "description" TEXT,
    "dueDate" TIMESTAMP(3),
    "completed" BOOLEAN NOT NULL DEFAULT false,
    "categoryId" TEXT,
    "userId" TEXT NOT NULL,

    CONSTRAINT "Task_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Category" (
    "id" TEXT NOT NULL,
    "name" VARCHAR(255) NOT NULL,

    CONSTRAINT "Category_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "Task" ADD CONSTRAINT "Task_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Task" ADD CONSTRAINT "Task_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240419085235_init/migration.sql
/*
  Warnings:

  - Made the column `categoryId` on table `Task` required. This step will fail if there are existing NULL values in that column.

*/
-- DropForeignKey
ALTER TABLE "Task" DROP CONSTRAINT "Task_categoryId_fkey";

-- AlterTable
ALTER TABLE "Task" ALTER COLUMN "categoryId" SET NOT NULL;

-- AddForeignKey
ALTER TABLE "Task" ADD CONSTRAINT "Task_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240425085502_init/migration.sql
/*
  Warnings:

  - Made the column `name` on table `User` required. This step will fail if there are existing NULL values in that column.

*/
-- CreateEnum
CREATE TYPE "TokenType" AS ENUM ('ACCESS', 'REFRESH', 'RESET_PASSWORD', 'VERIFY_EMAIL');

-- AlterTable
ALTER TABLE "User" ALTER COLUMN "name" SET NOT NULL;

-- CreateTable
CREATE TABLE "Token" (
    "id" SERIAL NOT NULL,
    "token" TEXT NOT NULL,
    "type" "TokenType" NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL,
    "blacklisted" BOOLEAN NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,

    CONSTRAINT "Token_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "Token" ADD CONSTRAINT "Token_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240430130308_init/migration.sql
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('USER', 'ADMIN');

-- AlterTable
ALTER TABLE "User" ADD COLUMN     "role" "Role" NOT NULL DEFAULT 'USER';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240521081151_init/migration.sql
-- AlterTable
ALTER TABLE "Token" ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240614091606_init/migration.sql
/*
  Warnings:

  - Added the required column `color` to the `Category` table without a default value. This is not possible if the table is not empty.

*/
-- AlterTable
ALTER TABLE "Category" ADD COLUMN     "color" VARCHAR(255) NOT NULL;

-- AlterTable
ALTER TABLE "Token" ALTER COLUMN "updatedAt" DROP DEFAULT;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240614114723_init/migration.sql
/*
  Warnings:

  - You are about to alter the column `color` on the `Category` table. The data in that column could be lost. The data in that column will be cast from `VarChar(255)` to `VarChar(7)`.

*/
-- AlterTable
ALTER TABLE "Category" ALTER COLUMN "color" SET DATA TYPE VARCHAR(7);


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240618131510_init/migration.sql
/*
  Warnings:

  - Added the required column `userId` to the `Category` table without a default value. This is not possible if the table is not empty.

*/
-- AlterTable
ALTER TABLE "Category" ADD COLUMN     "userId" TEXT NOT NULL;

-- AddForeignKey
ALTER TABLE "Category" ADD CONSTRAINT "Category_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/migration_lock.toml
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"

File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/schema.prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String
  password  String   @db.VarChar(255)
  role      Role     @default(USER)
  tasks     Task[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  categories Category[]
  Token     Token[]
}

model Token {
  id          Int       @id @default(autoincrement())
  token       String
  type        TokenType
  expires     DateTime
  blacklisted Boolean
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation(fields: [userId], references: [id])
  userId      String
}

model Task {
  id          String    @id @default(uuid())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  title       String    @db.VarChar(255)
  description String?
  dueDate     DateTime?
  completed   Boolean   @default(false)
  categoryId  String
  category    Category  @relation(fields: [categoryId], references: [id])
  userId      String
  user        User      @relation(fields: [userId], references: [id])
}

model Category {
  id    String @id @default(uuid())
  name  String @db.VarChar(255)
  color String @db.VarChar(7)
  userId String
  user  User   @relation(fields: [userId], references: [id])
  tasks Task[]
}

enum Role {
  USER
  ADMIN
}

enum TokenType {
  ACCESS
  REFRESH
  RESET_PASSWORD
  VERIFY_EMAIL
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/project.json
{
  "name": "todo-server",
  "$schema": "../../node_modules/nx/schemas/project-schema.json",
  "sourceRoot": "apps/todo-server/src",
  "projectType": "application",
  "tags": [],
  "targets": {
    "build": {
      "executor": "@nx/esbuild:esbuild",
      "outputs": ["{options.outputPath}"],
      "defaultConfiguration": "production",
      "options": {
        "platform": "node",
        "outputPath": "dist/apps/todo-server",
        "format": ["cjs"],
        "bundle": false,
        "main": "apps/todo-server/src/main.ts",
        "tsConfig": "apps/todo-server/tsconfig.app.json",
        "assets": ["apps/todo-server/src/assets"],
        "generatePackageJson": true,
        "esbuildOptions": {
          "sourcemap": true,
          "outExtension": {
            ".js": ".js"
          }
        }
      },
      "configurations": {
        "development": {},
        "production": {
          "esbuildOptions": {
            "sourcemap": false,
            "outExtension": {
              ".js": ".js"
            }
          }
        }
      }
    },
    "serve": {
      "executor": "@nx/js:node",
      "defaultConfiguration": "development",
      "options": {
        "buildTarget": "todo-server:build"
      },
      "configurations": {
        "development": {
          "buildTarget": "todo-server:build:development"
        },
        "production": {
          "buildTarget": "todo-server:build:production"
        }
      }
    },
    "test": {
      "executor": "@nx/jest:jest",
      "outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
      "options": {
        "jestConfig": "apps/todo-server/jest.config.ts"
      }
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/app.ts
import express from 'express';

import compression from 'compression';
import helmet from 'helmet';
import { xss } from 'express-xss-sanitizer';
import cors from 'cors';
import passport from 'passport';
import httpStatus from 'http-status';

import routes from './routes/v1';

import { errorConverter, errorHandler } from './middlewares';

import ApiError from './utils/ApiError';

import { jwtStrategy } from './config/passport';

const app = express();

app.use(helmet());

app.use(express.json());

app.use(express.urlencoded({ extended: true }));

app.use(xss());

app.use(compression());

app.use(cors());

app.use(passport.initialize());
passport.use('jwt', jwtStrategy);

app.use('/v1', routes);

app.use((req, res, next) => {
  next(new ApiError(httpStatus.NOT_FOUND, 'Not found'));
});

app.use(errorConverter);

app.use(errorHandler);

export default app;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/assets/.gitkeep


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/client.ts
import { PrismaClient } from '@prisma/client';

// Singleton instance
let prisma: PrismaClient;

if (!prisma) {
  prisma = new PrismaClient();

  process.on('SIGTERM', async () => await prisma.$disconnect());
}

export default prisma;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/config/config.ts
import dotenv from 'dotenv';
import path from 'path';
import { z } from 'zod';
import { fromError } from 'zod-validation-error';

dotenv.config({ path: path.join(process.cwd(), '.env') });

const envVarsSchema = z.object({
  NODE_ENV: z
    .enum(['production', 'development', 'test'])
    .default('development'),
  PORT: z
    .string()
    .transform((x) => Number(x))
    .default('3000'),
  JWT_SECRET: z.string().min(1).describe('JWT secret key'),
  JWT_ACCESS_EXPIRATION_MINUTES: z
    .string()
    .transform((x) => Number(x))
    .default('30')
    .describe('minutes after which access tokens expire'),
  JWT_REFRESH_EXPIRATION_DAYS: z
    .string()
    .transform((x) => Number(x))
    .default('30')
    .describe('days after which refresh tokens expire'),
  JWT_RESET_PASSWORD_EXPIRATION_MINUTES: z
    .string()
    .transform((x) => Number(x))
    .default('10')
    .describe('minutes after which reset password token expires'),
  JWT_VERIFY_EMAIL_EXPIRATION_MINUTES: z
    .string()
    .transform((x) => Number(x))
    .default('10')
    .describe('minutes after which verify email token expires'),
});

// Parse and validate environment variables
const envVars = envVarsSchema.safeParse(process.env);

if (!envVars.success) {
  const validationError = fromError(envVars.error);
  console.error('❌ Invalid environment variables:', validationError.details);
  process.exit(1);
}

export default {
  env: envVars.data.NODE_ENV,
  port: envVars.data.PORT,
  jwt: {
    secret: envVars.data.JWT_SECRET,
    accessExpirationMinutes: envVars.data.JWT_ACCESS_EXPIRATION_MINUTES,
    refreshExpirationDays: envVars.data.JWT_REFRESH_EXPIRATION_DAYS,
    resetPasswordExpirationMinutes:
      envVars.data.JWT_RESET_PASSWORD_EXPIRATION_MINUTES,
    verifyEmailExpirationMinutes:
      envVars.data.JWT_VERIFY_EMAIL_EXPIRATION_MINUTES,
  },
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/config/passport.ts
import {
  ExtractJwt,
  Strategy as JwtStrategy,
  StrategyOptionsWithoutRequest,
  VerifyCallback,
} from 'passport-jwt';
import { TokenType } from '@prisma/client';
import prisma from '../client';
import config from './config';

const jwtOptions: StrategyOptionsWithoutRequest = {
  secretOrKey: config.jwt.secret,
  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
};

const jwtVerify: VerifyCallback = async (payload, done) => {
  try {
    if (payload.type !== TokenType.ACCESS) {
      throw new Error('Invalid token type');
    }

    const user = await prisma.user.findUnique({
      where: { id: payload.sub },
    });
    if (!user) {
      return done(null, false);
    }
    done(null, user);
  } catch (error) {
    done(error, false);
  }
};

export const jwtStrategy = new JwtStrategy(jwtOptions, jwtVerify);


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/config/roles.ts
import { Role } from '@prisma/client';

const allRoles = {
  [Role.USER]: [],
  [Role.ADMIN]: ['getUsers', 'manageUsers'],
};

export const roles = Object.keys(allRoles);
export const roleRights = new Map(Object.entries(allRoles));


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/controllers/auth.controller.ts
import { Request, Response } from 'express';

import httpStatus from 'http-status';

import {
  ILogin,
  IRegister,
  LoginSchema,
  RegisterSchema,
} from '@myworkspace/data-models';

import { authService, tokenService, userService } from '../services';

import { catchAsync } from '../utils';

import { TokenType } from '@prisma/client';

export const register = catchAsync(async (req: Request, res: Response) => {
  RegisterSchema.parse(req.body);

  const { email, name, password } = req.body as IRegister;

  const user = await userService.createUser(email, name, password);

  return res.status(httpStatus.CREATED).json({
    message: 'User created successfully',
    data: { user },
  });
});

export const login = catchAsync(async (req: Request, res: Response) => {
  LoginSchema.parse(req.body);

  const { email, password } = req.body as ILogin;

  const user = await authService.loginUserWithEmailAndPassword(email, password);
  const tokens = await tokenService.generateAuthTokens(user);

  return res.status(httpStatus.OK).json({
    message: 'Login successful',
    data: { user, tokens },
  });
});

export const refreshToken = catchAsync(async (req: Request, res: Response) => {
  const { refreshToken } = req.body;

  const refreshTokenData = await tokenService.verifyToken(
    refreshToken,
    TokenType.REFRESH,
  );

  if (!refreshTokenData) {
    return res.status(httpStatus.UNAUTHORIZED).json({
      message: 'Invalid refresh token',
    });
  }

  const user = await userService.getUserById(refreshTokenData.userId);

  if (!user) {
    return res.status(httpStatus.NOT_FOUND).json({
      message: 'User not found',
    });
  }

  const accessToken = await tokenService.generateAccessToken(user);

  return res.status(httpStatus.OK).json({
    message: 'Token validated successfully',
    data: { user, accessToken },
  });
});

export const logout = catchAsync(async (req: Request, res: Response) => {
  const { refreshToken } = req.body;

  const refreshTokenData = await tokenService.verifyToken(
    refreshToken,
    TokenType.REFRESH,
  );

  if (!refreshTokenData) {
    return res.status(httpStatus.UNAUTHORIZED).json({
      message: 'Invalid refresh token',
    });
  }

  await authService.logout(refreshToken);

  return res.status(httpStatus.OK).json({
    message: 'Logout successful',
  });
});


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/controllers/category.controller.ts
import { Request, Response } from 'express';

import { categoryService } from '../services';

import {
  CreateCategorySchema,
  ICreateCategory,
  IUser,
} from '@myworkspace/data-models';
import { catchAsync } from '../utils';
import httpStatus from 'http-status';

export const createCategory = catchAsync(
  async (req: Request, res: Response) => {
    CreateCategorySchema.parse(req.body);

    const user = req.user as IUser;

    const { name, color } = req.body as ICreateCategory;

    const category = await categoryService.createCategory(name, color, user.id);

    return res.status(httpStatus.CREATED).json({
      message: `Category ${name} was created successfully`,
      data: { category },
    });
  },
);

export const getCategories = catchAsync(async (req: Request, res: Response) => {
  const user = req.user as IUser;

  const categories = await categoryService.getCategories(user.id);

  return res.status(httpStatus.OK).json({
    message: 'Categories retrieved successfully',
    data: { categories },
  });
});


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/controllers/index.ts
export * as authController from './auth.controller';
export * as categoryController from './category.controller';
export * as taskController from './task.controller';
export * as userController from './user.controller';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/controllers/task.controller.ts
import { Request, Response } from 'express';

export const createCategory = (req: Request, res: Response) => {
  res.status(200).json({ message: 'Hello' });
};

export const getCategories = (req: Request, res: Response) => {
  res.status(200).json({ message: 'Hello' });
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/controllers/user.controller.ts
import { Request, Response } from 'express';
import httpStatus from 'http-status';
import { userService } from '../services';
import { catchAsync } from '../utils';

export const getUser = catchAsync(async (req: Request, res: Response) => {
  const { userId } = req.params;

  const user = await userService.getUserById(userId);

  if (!user) {
    return res.status(httpStatus.NOT_FOUND).json({
      message: 'User not found',
    });
  }

  return res.status(httpStatus.OK).json({
    message: 'User retrieved successfully',
    data: { user },
  });
});


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/main.ts
import { Server } from 'http';
import prisma from './client';
import app from './app';
import config from './config/config';

let server: Server;

prisma.$connect().then(() => {
  server = app.listen(config.port, () => {
    console.log(`Server is running on port ${config.port}`);
  });
});

const exitHandler = () => {
  if (server) {
    server.close(() => {
      console.log('Server closed');
      process.exit(1);
    });
  } else {
    process.exit(1);
  }
};

const unexpectedErrorHandler = (error: Error) => {
  console.log(error);
  exitHandler();
};

process.on('uncaughtException', unexpectedErrorHandler);
process.on('unhandledRejection', unexpectedErrorHandler);

process.on('SIGTERM', () => {
  console.log('SIGTERM received');
  if (server) {
    server.close();
  }
});


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/middlewares/auth.ts
import passport, { AuthenticateCallback } from 'passport';
import httpStatus from 'http-status';
import ApiError from '../utils/ApiError';
import { roleRights } from '../config/roles';
import { NextFunction, Request, Response } from 'express';
import { User } from '@prisma/client';

const verifyCallback: (
  req: Request,
  resolve: (value?: unknown) => void,
  reject: (reason?: unknown) => void,
  requiredRights: string[],
) => AuthenticateCallback =
  (req, resolve, reject, requiredRights) =>
  async (
    err: any,
    user?: User | false | null,
    info?: object | string | Array<string | undefined>,
  ): Promise<void> => {
    if (err || info || !user) {
      return reject(
        new ApiError(httpStatus.UNAUTHORIZED, 'Please authenticate'),
      );
    }

    req.user = user;

    if (requiredRights.length) {
      const userRights = roleRights.get(user.role) ?? [];
      const hasRequiredRights = requiredRights.every((requiredRight) =>
        userRights.includes(requiredRight),
      );
      if (!hasRequiredRights && req.params.userId !== user.id) {
        return reject(new ApiError(httpStatus.FORBIDDEN, 'Forbidden'));
      }
    }

    resolve();
  };

const auth =
  (...requiredRights: string[]) =>
  async (req: Request, res: Response, next: NextFunction) => {
    return new Promise((resolve, reject) => {
      passport.authenticate(
        'jwt',
        { session: false },
        verifyCallback(req, resolve, reject, requiredRights),
      )(req, res, next);
    })
      .then(() => next())
      .catch((err) => next(err));
  };

export default auth;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/middlewares/error.ts
import { ErrorRequestHandler, NextFunction, Request, Response } from 'express';
import { Prisma } from '@prisma/client';
import httpStatus from 'http-status';
import ApiError from '../utils/ApiError';
import { ZodError } from 'zod';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import { fromError } from 'zod-validation-error';

export const errorConverter: ErrorRequestHandler = (
  err: PrismaClientKnownRequestError | ZodError | ApiError,
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  let error = err;

  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    const statusCode = httpStatus.BAD_REQUEST;
    const message = error.message;
    error = new ApiError(statusCode, message, false);
  }

  if (error instanceof ZodError) {
    const validationError = fromError(error);
    const statusCode = httpStatus.BAD_REQUEST;
    const message = validationError.message;

    error = new ApiError(statusCode, message, false, validationError.details);
  }

  return next(error);
};

export const errorHandler: ErrorRequestHandler = (
  err: ApiError,
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  const { statusCode, message, errors } = err;

  const response = {
    statusCode,
    message,
    errors,
  };

  return res.status(statusCode).json(response);
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/middlewares/index.ts
export * from './error';
export * from './auth';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/routes/v1/auth.route.ts
import express from 'express';

import { authController } from '../../controllers';

import auth from '../../middlewares/auth';

const router = express.Router();

router.post('/register', authController.register);

router.post('/login', authController.login);

router.post('/refresh-token', authController.refreshToken);

router.post('/logout', auth(), authController.logout);

export default router;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/routes/v1/category.route.ts
import express from 'express';

import { categoryController } from '../../controllers/';
import auth from '../../middlewares/auth';

const router = express.Router();

router.get('/', auth(), categoryController.getCategories);
router.post('/create', auth(), categoryController.createCategory);

export default router;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/routes/v1/index.ts
import express from 'express';
import authRoute from './auth.route';
import taskRoute from './task.route';
import userRoute from './user.route';
import categoryRoute from './category.route';

const router = express.Router();

const defaultRoutes = [
  {
    path: '/auth',
    route: authRoute,
  },
  {
    path: '/task',
    route: taskRoute,
  },
  {
    path: '/user',
    route: userRoute,
  },
  {
    path: '/category',
    route: categoryRoute,
  },
];

defaultRoutes.forEach((route) => {
  router.use(route.path, route.route);
});

export default router;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/routes/v1/task.route.ts
import express from 'express';

import { taskController } from '../../controllers';
import auth from '../../middlewares/auth';

const router = express.Router();

// router.post('/test', auth(), taskController.test);

export default router;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/routes/v1/user.route.ts
import express from 'express';

import { userController } from '../../controllers';

import auth from '../../middlewares/auth';

const router = express.Router();

router.get('/:userId', auth(), userController.getUser);
// router.put('/:userId', auth(), userController.updateUser);
// router.delete('/:userId', auth(), userController.deleteUser);

export default router;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/services/auth.service.ts
import prisma from '../client';
import ApiError from '../utils/ApiError';
import { matchPassword } from '../utils';
import httpStatus from 'http-status';
import { exclude } from '../utils/exclude';
import { tokenService } from '.';
import { TokenType } from '@prisma/client';

export const loginUserWithEmailAndPassword = async (
  email: string,
  password: string,
) => {
  const user = await prisma.user.findUnique({
    where: {
      email,
    },
  });

  if (!user) throw new ApiError(httpStatus.NOT_FOUND, 'User not found');

  const isPasswordValid = await matchPassword(password, user.password);

  if (!isPasswordValid)
    throw new ApiError(httpStatus.BAD_REQUEST, 'Invalid password');

  return exclude(user, ['password', 'createdAt', 'updatedAt']);
};

export const refreshAuth = async (refreshToken: string) => {
  const refreshTokenData = await tokenService.verifyToken(
    refreshToken,
    TokenType.REFRESH,
  );

  if (!refreshTokenData)
    throw new ApiError(httpStatus.NOT_FOUND, 'Refresh token not found');

  const { userId } = refreshTokenData;

  await prisma.token.delete({
    where: {
      id: refreshTokenData.id,
    },
  });

  return tokenService.generateAuthTokens({ id: userId });
};

export const logout = async (refreshToken: string) => {
  const tokenToDelete = await prisma.token.findFirst({
    where: {
      token: refreshToken,
      type: TokenType.REFRESH,
      blacklisted: false,
    },
  });

  if (!tokenToDelete)
    throw new ApiError(httpStatus.NOT_FOUND, 'Token not found');

  await prisma.token.delete({
    where: {
      id: tokenToDelete.id,
    },
  });
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/services/category.service.ts
import { exclude } from './../utils/exclude';
import httpStatus from 'http-status';
import prisma from '../client';
import ApiError from '../utils/ApiError';

export const createCategory = async (
  name: string,
  color: string,
  userId: string,
) => {
  const category = await prisma.category.create({
    data: {
      name,
      color,
      userId,
    },
    select: {
      id: true,
      name: true,
      color: true,
    },
  });

  return category;
};

export const getCategoryById = async (id: string, userId: string) => {
  const category = await prisma.category.findUnique({
    where: {
      id,
      userId,
    },
  });

  if (!category) throw new ApiError(httpStatus.NOT_FOUND, 'Category not found');

  return category;
};

export const getCategories = async (userId: string) => {
  const categories = await prisma.category.findMany({
    where: {
      userId,
    },
    select: {
      id: true,
      name: true,
      color: true,
    },
  });

  if (!categories)
    throw new ApiError(httpStatus.NOT_FOUND, 'Categories not found');

  return categories;
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/services/index.ts
export * as authService from './auth.service';
export * as categoryService from './category.service';
export * as tokenService from './token.service';
export * as userService from './user.service';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/services/token.service.ts
import { BaseUserSchema, ITokens } from '@myworkspace/data-models';
import z from 'zod';
import { TokenType } from '@prisma/client';
import jwt from 'jsonwebtoken';
import config from '../config/config.js';
import prisma from '../client.js';
import ApiError from '../utils/ApiError.js';
import httpStatus from 'http-status';

interface JwtPayload {
  sub: string;
  iat: number;
  exp: number;
  type: TokenType;
}

const generateToken = (
  userId: string,
  expires: Date,
  type: TokenType,
  secret = config.jwt.secret,
): string => {
  const payload: JwtPayload = {
    sub: userId,
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(expires.getTime() / 1000),
    type,
  };
  return jwt.sign(payload, secret);
};

const saveToken = async (
  userId: string,
  token: string,
  expires: Date,
  type: TokenType,
  blacklisted = false,
) => {
  const existingToken = await prisma.token.findFirst({
    where: {
      userId,
      type,
    },
  });

  if (existingToken) {
    await prisma.token.update({
      where: {
        id: existingToken.id,
      },
      data: {
        token,
        expires,
        blacklisted,
      },
    });

    return existingToken;
  }

  return await prisma.token.create({
    data: {
      userId,
      token,
      expires,
      type,
      blacklisted,
    },
  });
};

export const generateAccessToken = async (
  user: z.infer<typeof BaseUserSchema>,
) => {
  const { id: userId } = user;

  const expires = Date.now() + config.jwt.accessExpirationMinutes * 60 * 1000;

  const token = generateToken(userId, new Date(expires), TokenType.ACCESS);

  return { token, expires, type: TokenType.ACCESS };
};

export const generateAuthTokens = async (
  user: z.infer<typeof BaseUserSchema>,
): Promise<ITokens> => {
  const { id: userId } = user;

  const accessTokenExpires =
    Date.now() + config.jwt.accessExpirationMinutes * 60 * 1000;

  const refreshTokenExpires =
    Date.now() + config.jwt.refreshExpirationDays * 24 * 60 * 60 * 1000;

  const accessToken = generateToken(
    userId,
    new Date(accessTokenExpires),
    TokenType.ACCESS,
  );

  const refreshToken = generateToken(
    userId,
    new Date(refreshTokenExpires),
    TokenType.REFRESH,
  );

  await saveToken(
    userId,
    refreshToken,
    new Date(refreshTokenExpires),
    TokenType.REFRESH,
  );

  return {
    access: {
      token: accessToken,
      expires: accessTokenExpires,
      type: TokenType.ACCESS,
    },
    refresh: {
      token: refreshToken,
      expires: refreshTokenExpires,
      type: TokenType.REFRESH,
    },
  };
};

export const verifyToken = async (token: string, type: TokenType) => {
  const payload = jwt.verify(token, config.jwt.secret) as JwtPayload;

  const userId = payload.sub;

  if (payload.type !== type)
    throw new ApiError(httpStatus.UNPROCESSABLE_ENTITY, 'Invalid token type');

  const tokenData = await prisma.token.findFirst({
    where: {
      userId,
      token,
      type,
      blacklisted: false,
    },
  });

  if (!tokenData) throw new ApiError(httpStatus.NOT_FOUND, 'Token not found');

  return tokenData;
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/services/user.service.ts
import prisma from '../client';
import ApiError from '../utils/ApiError';
import httpStatus from 'http-status';
import { encrypt, exclude } from '../utils';

export const createUser = async (
  email: string,
  name: string,
  password: string,
) => {
  const userExists = await prisma.user.findUnique({
    where: {
      email,
    },
  });

  if (userExists)
    throw new ApiError(httpStatus.CONFLICT, 'User already exists');

  const hashedPassword = await encrypt(password);

  const user = await prisma.user.create({
    data: {
      email,
      name,
      password: hashedPassword,
    },
  });

  return exclude(user, ['password', 'createdAt', 'updatedAt']);
};

export const getUserById = async (id: string) => {
  const user = await prisma.user.findUnique({
    where: {
      id,
    },
  });

  if (!user) throw new ApiError(httpStatus.NOT_FOUND, 'User not found');

  return exclude(user, ['password', 'createdAt', 'updatedAt']);
};

export const getUserByEmail = async (email: string) => {
  const user = await prisma.user.findUnique({
    where: {
      email,
    },
  });

  if (!user) throw new ApiError(httpStatus.NOT_FOUND, 'User not found');

  return exclude(user, ['password', 'createdAt', 'updatedAt']);
};

export const getUsers = async () => {
  const users = await prisma.user.findMany();
  return users;
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/ApiError.ts
class ApiError extends Error {
  statusCode: number;
  isOperational: boolean;
  errors: any[];

  constructor(
    statusCode: number,
    message?: string,
    isOperational = true,
    errors: any[] = []
  ) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.errors = errors;
  }
}

export default ApiError;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/catchAsync.ts
import { NextFunction, Request, RequestHandler, Response } from 'express';

export const catchAsync =
  (fn: RequestHandler) => (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/encryption.ts
import bcrypt from 'bcrypt';

export const encrypt = async (password: string) => {
  return await bcrypt.hash(password, 8);
};

export const matchPassword = (password: string, userPassword: string) => {
  return bcrypt.compare(password, userPassword);
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/exclude.ts
export const exclude = <Type, Key extends keyof Type>(
  obj: Type,
  keys: Key[]
): Omit<Type, Key> => {
  for (const key of keys) {
    delete obj[key];
  }
  return obj;
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/index.ts
export * from './ApiError';
export * from './catchAsync';
export * from './encryption';
export * from './exclude';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/tsconfig.app.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "module": "commonjs",
    "types": ["node"]
  },
  "exclude": ["jest.config.ts", "src/**/*.spec.ts", "src/**/*.test.ts"],
  "include": ["src/**/*.ts"]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.spec.json"
    }
  ],
  "compilerOptions": {
    "esModuleInterop": true
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/tsconfig.spec.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "module": "commonjs",
    "types": ["jest", "node"]
  },
  "include": [
    "jest.config.ts",
    "src/**/*.test.ts",
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}


