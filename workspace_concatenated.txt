File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/.eslintrc.json
{
  "extends": ["../../.eslintrc.json"],
  "ignorePatterns": ["!**/*"],
  "overrides": [
    {
      "files": ["*.ts"],
      "extends": [
        "plugin:@nx/angular",
        "plugin:@angular-eslint/template/process-inline-templates"
      ],
      "rules": {
        "@angular-eslint/directive-selector": [
          "error",
          {
            "type": "attribute",
            "prefix": "app",
            "style": "camelCase"
          }
        ],
        "@angular-eslint/component-selector": [
          "error",
          {
            "type": "element",
            "prefix": "app",
            "style": "kebab-case"
          }
        ]
      }
    },
    {
      "files": ["*.html"],
      "extends": ["plugin:@nx/angular-template"],
      "rules": {}
    }
  ]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/jest.config.ts
/* eslint-disable */
export default {
  displayName: 'todo-app',
  preset: '../../jest.preset.js',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
  coverageDirectory: '../../coverage/apps/todo-app',
  transform: {
    '^.+\\.(ts|mjs|js|html)$': [
      'jest-preset-angular',
      {
        tsconfig: '<rootDir>/tsconfig.spec.json',
        stringifyContentPathRegex: '\\.(html|svg)$',
      },
    ],
  },
  transformIgnorePatterns: ['node_modules/(?!.*\\.mjs$)'],
  snapshotSerializers: [
    'jest-preset-angular/build/serializers/no-ng-attributes',
    'jest-preset-angular/build/serializers/ng-snapshot',
    'jest-preset-angular/build/serializers/html-comment',
  ],
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/project.json
{
  "name": "todo-app",
  "$schema": "../../node_modules/nx/schemas/project-schema.json",
  "projectType": "application",
  "prefix": "app",
  "sourceRoot": "apps/todo-app/src",
  "tags": [],
  "targets": {
    "build": {
      "executor": "@angular-devkit/build-angular:application",
      "outputs": ["{options.outputPath}"],
      "options": {
        "outputPath": "dist/apps/todo-app",
        "index": "apps/todo-app/src/index.html",
        "browser": "apps/todo-app/src/main.ts",
        "polyfills": ["zone.js"],
        "tsConfig": "apps/todo-app/tsconfig.app.json",
        "inlineStyleLanguage": "scss",
        "assets": ["apps/todo-app/src/favicon.ico", "apps/todo-app/src/assets"],
        "styles": [
          "apps/todo-app/src/styles.scss",
          "node_modules/ngx-toastr/toastr.css"
        ],
        "scripts": []
      },
      "configurations": {
        "production": {
          "budgets": [
            {
              "type": "initial",
              "maximumWarning": "500kb",
              "maximumError": "1mb"
            },
            {
              "type": "anyComponentStyle",
              "maximumWarning": "2kb",
              "maximumError": "4kb"
            }
          ],
          "outputHashing": "all"
        },
        "development": {
          "optimization": false,
          "extractLicenses": false,
          "sourceMap": true
        }
      },
      "defaultConfiguration": "production"
    },
    "serve": {
      "executor": "@angular-devkit/build-angular:dev-server",
      "configurations": {
        "production": {
          "buildTarget": "todo-app:build:production"
        },
        "development": {
          "buildTarget": "todo-app:build:development"
        }
      },
      "defaultConfiguration": "development",
      "options": {
        "proxyConfig": "apps/todo-app/proxy.conf.json"
      }
    },
    "extract-i18n": {
      "executor": "@angular-devkit/build-angular:extract-i18n",
      "options": {
        "buildTarget": "todo-app:build"
      }
    },
    "lint": {
      "executor": "@nx/eslint:lint"
    },
    "test": {
      "executor": "@nx/jest:jest",
      "outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
      "options": {
        "jestConfig": "apps/todo-app/jest.config.ts"
      }
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/proxy.conf.json
{
  "/api": {
    "target": "http://localhost:3000",
    "secure": false
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/app.component.html
<router-outlet></router-outlet>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/app.component.scss


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/app.component.ts
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { RouterModule } from '@angular/router';
import { AuthService, TokenService } from '@lib/services';

@Component({
  standalone: true,
  imports: [RouterModule],
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrl: './app.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class AppComponent {}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/app.config.ts
import { ApplicationConfig } from '@angular/core';
import { provideRouter, withViewTransitions } from '@angular/router';
import { appRoutes } from './app.routes';
import { provideAnimationsAsync } from '@angular/platform-browser/animations/async';
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { jwtInterceptor, serverErrorInterceptor } from '@lib/interceptors';
import { provideToastr } from 'ngx-toastr';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(
      appRoutes,
      withViewTransitions({ skipInitialTransition: true }),
    ),
    provideAnimationsAsync(),
    provideHttpClient(
      withInterceptors([jwtInterceptor, serverErrorInterceptor]),
    ),
    provideToastr(),
  ],
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/app.routes.ts
import { Route } from '@angular/router';
import { authGuard } from '@lib/guards';

export const appRoutes: Route[] = [
  {
    path: 'auth',
    loadChildren: async () => await import('@pages/auth').then((m) => m.routes),
    canMatch: [authGuard({ requiresAuthentication: false })],
  },

  {
    path: '',
    loadChildren: async () =>
      await import('@pages/dashboard').then((m) => m.routes),
    canMatch: [authGuard()],
  },
];


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/index.ts
export * from './navbar/navbar.component';
export * from './sidenav/sidenav.component';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/navbar/navbar.component.html
<app-sidenav #drawer [isHandset]="isHandset()">
  <ng-content />
</app-sidenav>

<mat-toolbar color="primary">
  @if (isHandset()) {
    <button
      (click)="drawer.toggleDrawer()"
      type="button"
      aria-label="Toggle sidenav"
      mat-icon-button
    >
      <mat-icon aria-label="Side nav toggle icon">menu</mat-icon>
    </button>
  }
  <span>todo-app</span>
</mat-toolbar>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/navbar/navbar.component.scss
.mat-toolbar.mat-primary {
  position: absolute;
  z-index: 1;
  bottom: 0;
  height: 4rem;
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/navbar/navbar.component.ts
import { ChangeDetectionStrategy, Component, input } from '@angular/core';
import { AsyncPipe } from '@angular/common';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatButtonModule } from '@angular/material/button';
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatListModule } from '@angular/material/list';
import { MatIconModule } from '@angular/material/icon';
import { RouterLink } from '@angular/router';
import { SidenavComponent } from '@lib/components/sidenav/sidenav.component';

@Component({
  selector: 'app-navbar',
  templateUrl: './navbar.component.html',
  styleUrl: './navbar.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: true,
  imports: [
    MatToolbarModule,
    MatButtonModule,
    MatSidenavModule,
    MatListModule,
    MatIconModule,
    AsyncPipe,
    RouterLink,
    SidenavComponent,
  ],
})
export class NavbarComponent {
  isHandset = input.required<boolean | null>();
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/sidenav/sidenav.component.html
<mat-sidenav-container class="sidenav-container">
  <mat-sidenav
    class="sidenav"
    #drawer
    [mode]="isHandset() ? 'over' : 'side'"
    [attr.role]="isHandset() ? 'dialog' : 'navigation'"
    [opened]="isSideNavOpen() || !isHandset()"
    fixedInViewport
  >
    <mat-toolbar>Menu</mat-toolbar>
    <mat-nav-list class="sidenav-list">
      <a
        [routerLinkActiveOptions]="{ exact: true }"
        mat-list-item
        color="primary"
        routerLinkActive="active-link"
        routerLink="/"
      >
        <mat-icon
          aria-hidden="false"
          aria-label="Example home icon"
          fontIcon="calendar_today"
        />
        <span>Recent</span>
      </a>
      <a
        [routerLinkActiveOptions]="{ exact: true }"
        mat-list-item
        routerLinkActive="active-link"
        routerLink="/done"
        ><mat-icon
          aria-hidden="false"
          aria-label="Example home icon"
          fontIcon="event_available"
        />Done</a
      >
      <a
        [routerLinkActiveOptions]="{ exact: true }"
        routerLinkActive="active-link"
        routerLink="/inbox"
        mat-list-item
        ><mat-icon
          aria-hidden="false"
          aria-label="Example home icon"
          fontIcon="inbox"
        />Inbox</a
      >
    </mat-nav-list>
  </mat-sidenav>
  <mat-sidenav-content>
    <ng-content />
  </mat-sidenav-content>
</mat-sidenav-container>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/sidenav/sidenav.component.scss
.sidenav-container {
  height: 100vh;

  .sidenav {
    width: 200px;
    height: calc(100vh - 4rem);

    .mat-toolbar {
      background: inherit;
    }

    .active-link {
      background: rgba(var(--secondary-color), 0.8);
    }

    &::ng-deep.mdc-list-item__primary-text {
      display: flex;
      align-items: center;
      gap: 1rem;
      font-size: 1.1rem;
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/components/sidenav/sidenav.component.ts
import {
  ChangeDetectionStrategy,
  Component,
  input,
  signal,
  viewChild,
} from '@angular/core';
import { MatSidenav, MatSidenavModule } from '@angular/material/sidenav';
import { MatToolbar } from '@angular/material/toolbar';
import { MatListItem, MatNavList } from '@angular/material/list';
import { RouterLink, RouterLinkActive } from '@angular/router';
import { MatIconModule } from '@angular/material/icon';

@Component({
  selector: 'app-sidenav',
  standalone: true,
  imports: [
    MatSidenavModule,
    MatToolbar,
    MatNavList,
    MatListItem,
    RouterLink,
    RouterLinkActive,
    MatIconModule,
  ],
  templateUrl: './sidenav.component.html',
  styleUrl: './sidenav.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SidenavComponent {
  isHandset = input.required<boolean | null>();

  drawer = viewChild.required<MatSidenav>('drawer');

  isSideNavOpen = signal(false);

  toggleDrawer() {
    this.isSideNavOpen.update((state) => !state);
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/guards/auth/auth.guard.ts
import { CanMatchFn, Route, Router, UrlSegment } from '@angular/router';
import { inject } from '@angular/core';
import { AuthService } from '@lib/services';
import { map } from 'rxjs';

interface AuthGuardOptions {
  requiresAuthentication: boolean;
}

const defaultAuthGuardOptions = (): AuthGuardOptions => ({
  requiresAuthentication: true,
});

export const authGuard = (
  options: AuthGuardOptions = defaultAuthGuardOptions(),
): CanMatchFn => {
  return (_: Route, segments: UrlSegment[]) => {
    const router = inject(Router);
    const authService = inject(AuthService);

    return authService.refreshToken().pipe(
      map((res: boolean) => {
        if (
          options.requiresAuthentication &&
          (authService.isAuthenticated() || res)
        ) {
          return true;
        }

        const currentUrl = segments.map((s) => s.path).join('/');
        const isAuthPage =
          currentUrl === 'auth/login' || currentUrl === 'auth/register';

        if (isAuthPage) {
          return true; // Allow access to the login page
        }

        return options.requiresAuthentication
          ? router.createUrlTree(['/auth/login'], {
              queryParams: {
                returnUrl: currentUrl,
              },
            })
          : router.createUrlTree(['/']);
      }),
    );
  };
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/guards/index.ts
export * from './auth/auth.guard';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interceptors/index.ts
export * from './jwt.interceptor';
export * from './server-error.interceptor';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interceptors/jwt.interceptor.ts
import { AuthService, TokenService } from '@lib/services';
import type { HttpInterceptorFn } from '@angular/common/http';
import { inject } from '@angular/core';

export const jwtInterceptor: HttpInterceptorFn = (req, next) => {
  const authService = inject(AuthService);
  const tokenService = inject(TokenService);

  if (authService.isAuthenticated() && tokenService.accessToken) {
    req = req.clone({
      setHeaders: {
        Authorization: `Bearer ${tokenService.accessToken}`,
      },
    });
  }

  return next(req);
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interceptors/server-error.interceptor.ts
import {
  HttpErrorResponse,
  HttpInterceptorFn,
  HttpRequest,
  HttpStatusCode,
} from '@angular/common/http';
import { inject } from '@angular/core';

import { AuthService, TokenService } from '@lib/services';
import { catchError, switchMap, throwError, EMPTY } from 'rxjs';

export const serverErrorInterceptor: HttpInterceptorFn = (req, next) => {
  const authSvc = inject(AuthService);
  const tokenSvc = inject(TokenService);

  const handleUnauthorizedError = (req: HttpRequest<unknown>) => {
    if (tokenSvc.refreshToken) {
      return authSvc.refreshToken().pipe(
        switchMap((res: boolean) => {
          if (res) {
            const { accessToken } = tokenSvc;

            const modifiedReq = req.clone({
              setHeaders: {
                Authorization: `Bearer ${accessToken}`,
              },
            });

            return next(modifiedReq);
          }

          // Refresh token failed
          authSvc.logout();

          return EMPTY;
        }),
      );
    }

    // No refresh token
    authSvc.logout();

    return EMPTY;
  };

  return next(req).pipe(
    catchError((error: HttpErrorResponse) => {
      switch (error.status) {
        case HttpStatusCode.Forbidden:
          authSvc.logout();
          return EMPTY;

        case HttpStatusCode.Unauthorized:
          return handleUnauthorizedError(req);

        case 0:
          return throwError(
            () =>
              new Error(
                'No internet connection. Please check your network and try again.',
              ),
          );

        default:
          return throwError(() => error);
      }
    }),
  );
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interfaces/index.ts
export * from './response.interface';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/interfaces/response.interface.ts
export interface IApiResponse<T> {
  message: string;
  data: T;
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/auth.service.ts
import {
  ILoginResponse,
  IRefreshTokenResponse,
  IRegisterResponse,
} from '@myworkspace/data-models';
import { inject, Injectable, signal } from '@angular/core';

import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import {
  catchError,
  Observable,
  of,
  switchMap,
  throttleTime,
  throwError,
} from 'rxjs';
import { TokenService } from './token.service';
import { UserService } from './user.service';
import { IApiResponse } from '@lib/interfaces';
import { TokenType } from '@prisma/client';
import { ActivatedRoute, Router } from '@angular/router';

@Injectable({
  providedIn: 'root',
})
export class AuthService {
  private readonly httpClient = inject(HttpClient);
  private readonly router = inject(Router);

  private readonly tokenSvc = inject(TokenService);
  private readonly userSvc = inject(UserService);

  readonly isAuthenticated = signal<boolean>(false);

  login(
    email: string,
    password: string,
  ): Observable<IApiResponse<ILoginResponse>> {
    return this.httpClient
      .post<IApiResponse<ILoginResponse>>(
        'http://localhost:3000/v1/auth/login',
        {
          email,
          password,
        },
      )
      .pipe(
        switchMap((res: IApiResponse<ILoginResponse>) => {
          const { tokens, user } = res.data;

          this.userSvc.user.set(user);
          this.tokenSvc.setTokens(tokens);
          this.isAuthenticated.set(true);

          return of(res);
        }),
        catchError((error: HttpErrorResponse) => {
          return throwError(() => error);
        }),
      );
  }

  refreshToken(): Observable<boolean> {
    const { refreshToken } = this.tokenSvc;

    if (!refreshToken) {
      this.clearSession();
      return of(false);
    }

    if (this.isAuthenticated() && this.tokenSvc.accessToken) {
      return of(true);
    }

    return this.httpClient
      .post<IApiResponse<IRefreshTokenResponse>>(
        'http://localhost:3000/v1/auth/refresh-token',
        {
          refreshToken,
        },
      )
      .pipe(
        switchMap((res: IApiResponse<IRefreshTokenResponse>) => {
          if (res.data.user) {
            this.isAuthenticated.set(true);
            this.userSvc.user.set(res.data.user);
            this.tokenSvc.setToken(
              res.data.accessToken.token,
              TokenType.ACCESS,
              res.data.accessToken.expires,
            );

            return of(true);
          }

          this.clearSession();
          return of(false);
        }),
        catchError((error: HttpErrorResponse) => {
          this.clearSession();
          return of(false);
        }),
      );
  }

  register(
    name: string,
    email: string,
    password: string,
    confirmPassword: string,
  ) {
    return this.httpClient
      .post<IApiResponse<IRegisterResponse>>(
        'http://localhost:3000/v1/auth/register',
        {
          name,
          email,
          password,
          confirmPassword,
        },
      )
      .pipe(
        switchMap((res: IApiResponse<IRegisterResponse>) => {
          this.router.navigateByUrl('/auth/login');
          return of(res);
        }),
        catchError((error: HttpErrorResponse) => {
          return throwError(() => error);
        }),
      );
  }

  logout(): void {
    this.clearSession();
    this.router.navigateByUrl('/auth/login');
  }

  private clearSession(): void {
    this.tokenSvc.clear();
    this.isAuthenticated.set(false);
    this.userSvc.user.set(null);
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/index.ts
export * from './auth.service';
export * from './token.service';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/token.service.ts
import { inject, Injectable } from '@angular/core';
import { ITokens } from '@myworkspace/data-models';
import { TokenType } from '@prisma/client';
import { CookieService } from 'ngx-cookie-service';

@Injectable({
  providedIn: 'root',
})
export class TokenService {
  private readonly cookieSvc = inject(CookieService);

  get accessToken(): string {
    return this.cookieSvc.get('accessToken');
  }

  get refreshToken(): string {
    return this.cookieSvc.get('refreshToken');
  }

  setTokens(tokens: ITokens): void {
    this.setToken(tokens.access.token, TokenType.ACCESS, tokens.access.expires);

    this.setToken(
      tokens.refresh.token,
      TokenType.REFRESH,
      tokens.refresh.expires,
    );
  }

  setToken(token: string, type: TokenType, expires: number) {
    const cookieName = this.getCookieName(type);

    this.cookieSvc.set(cookieName, token, {
      expires: new Date(expires),
      sameSite: 'Strict',
      secure: false, // Set to true if using HTTPS
      path: '/',
    });
  }

  private getCookieName(type: TokenType): string {
    switch (type) {
      case TokenType.ACCESS:
        return 'accessToken';
      case TokenType.REFRESH:
        return 'refreshToken';
      default:
        throw new Error('Invalid token type');
    }
  }

  clear(): void {
    this.cookieSvc.delete('accessToken');
    this.cookieSvc.delete('refreshToken');
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/services/user.service.ts
import { Injectable, signal } from '@angular/core';
import { IUser } from '@myworkspace/data-models';

@Injectable({
  providedIn: 'root',
})
export class UserService {
  readonly user = signal<IUser | null>(null);
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/validators/match-validator.ts
import {
  ValidatorFn,
  AbstractControl,
  ValidationErrors,
  FormGroup,
} from '@angular/forms';

export function matchValidator(matchingControlName: string): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const group = control.parent as FormGroup;

    if (!group) {
      return null;
    }

    const matchingControl = group.controls[matchingControlName];
    const controlValue = control.value;
    const matchingControlValue = matchingControl.value;

    if (controlValue !== matchingControlValue) {
      return { noMatching: true };
    }

    return null;
  };
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/lib/validators/zod-validator.validator.ts
import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';
import { fromError } from 'zod-validation-error';
import { ZodSchema } from 'zod';

export function zodValidator(schema: ZodSchema): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const result = schema.safeParse(control.value);
    if (result.success) {
      return null;
    }

    const zodErrors = fromError(result.error).details;

    const errors = zodErrors.reduce(
      (acc, error) => {
        acc[error.code] = error.message;
        return acc;
      },
      {} as Record<string, string>,
    );

    return errors;
  };
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/index.ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: 'login',
    title: 'Login',
    loadComponent: async () =>
      await import('./login/login.component').then((m) => m.LoginComponent),
  },
  {
    path: 'register',
    title: 'Register',
    loadComponent: async () =>
      await import('./register/register.component').then(
        (m) => m.RegisterComponent
      ),
  },
];


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/login/login.component.html
<div class="container">
  <form
    class="container__form"
    [formGroup]="loginForm"
    (keydown.enter)="onSignIn()"
  >
    <h1 class="container__form__title">Sign in to Cando</h1>

    <mat-form-field>
      <mat-label>Email</mat-label>
      <input [formControl]="email" matInput />
      @if (email.hasError('required') && (email.dirty || email.touched)) {
        <mat-error> Email is required </mat-error>
      } @else if (
        email.hasError('invalid_string') && (email.dirty || email.touched)
      ) {
        <mat-error> {{ email.getError('invalid_string') }} </mat-error>
      }
    </mat-form-field>

    <mat-form-field>
      <mat-label>Password</mat-label>
      <input [formControl]="password" type="password" matInput />
      @if (password.hasError('required') && (email.dirty || password.touched)) {
        <mat-error> Password is required </mat-error>
      } @else if (
        password.hasError('too_small') && (password.dirty || password.touched)
      ) {
        <mat-error> {{ password.getError('too_small') }} </mat-error>
      }
    </mat-form-field>

    <button
      [disabled]="loginForm.invalid || isSubmitted()"
      (click)="onSignIn()"
      color="primary"
      mat-flat-button
      type="button"
    >
      Sign In
    </button>
  </form>

  <div class="container__info">
    <h1>Hello, Friend!</h1>
    <button
      [routerLink]="['/auth', 'register']"
      type="button"
      color="primary"
      mat-flat-button
    >
      Sign Up
    </button>
  </div>
</div>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/login/login.component.scss
:host {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100vw;
  height: 100vh;
  background: var(--main-color)
}

.container {
  display: flex;
  overflow: hidden;
  justify-content: space-between;
  width: 50rem;
  border-radius: 0.5rem;
  background: var(--white-color);

  &__info {
    display: flex;
    align-items: center;
    flex-direction: column;
    justify-content: center;
    padding: 2rem;
    color: var(--white-color);
    background: var(--secondary-color)
  }

  &__form {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    padding: 5rem;

    &__title {
      margin-top: 0;
      text-align: center;
      color: var(--main-color);
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/login/login.component.ts
import {
  ChangeDetectionStrategy,
  Component,
  inject,
  signal,
  Signal,
} from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatButtonModule } from '@angular/material/button';
import { MatFormField, MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { Router, RouterLink } from '@angular/router';
import { AuthService } from '@lib/services';
import {
  FormControl,
  FormGroup,
  FormsModule,
  ReactiveFormsModule,
  Validators,
} from '@angular/forms';
import { zodValidator } from '@lib/validators/zod-validator.validator';
import { LoginSchema } from '@myworkspace/data-models';
import { injectQueryParams } from 'ngxtension/inject-query-params';
import { ToastrService } from 'ngx-toastr';
import { HttpErrorResponse } from '@angular/common/http';

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [
    CommonModule,
    MatButtonModule,
    MatFormField,
    RouterLink,
    ReactiveFormsModule,
    FormsModule,
    MatFormFieldModule,
    MatInputModule,
  ],
  templateUrl: './login.component.html',
  styleUrl: './login.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class LoginComponent {
  private readonly authSvc = inject(AuthService);
  private readonly toastrSvc = inject(ToastrService);

  private readonly router = inject(Router);

  protected isSubmitted = signal(false);

  readonly returnUrl = injectQueryParams('returnUrl', {
    initialValue: '/',
  }) as Signal<string>;

  email = new FormControl<string>('', [
    zodValidator(LoginSchema.shape.email),
    Validators.required,
  ]);
  password = new FormControl<string>('', [
    zodValidator(LoginSchema.shape.password),
    Validators.required,
  ]);

  loginForm = new FormGroup({
    email: this.email,
    password: this.password,
  });

  onSignIn(): void {
    if (this.loginForm.invalid) return;

    this.isSubmitted.set(true);

    this.authSvc
      .login(this.email.value as string, this.password.value as string)
      .subscribe({
        complete: () => {
          this.router.navigateByUrl(this.returnUrl());
          this.toastrSvc.success('Logged in successfully');
          this.isSubmitted.set(false);
        },
        error: (error: HttpErrorResponse | Error) => {
          const errorMessage =
            error instanceof HttpErrorResponse
              ? error.error.message
              : error.message;

          this.toastrSvc.error(errorMessage);
          this.isSubmitted.set(false);
        },
      });
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/register/register.component.html
<div class="container">
  <div class="container__info">
    <h1>Welcome Back</h1>
    <button
      [routerLink]="['/auth', 'login']"
      color="primary"
      mat-flat-button
      type="button"
    >
      Sign In
    </button>
  </div>
  <form class="container__form">
    <h1 class="container__form__title">Create Account</h1>

    <mat-form-field>
      <mat-label>Name</mat-label>
      <input [formControl]="name" matInput />
      @if (name.hasError('required') && (name.dirty || name.touched)) {
        <mat-error> Name is required </mat-error>
      } @else if (name.hasError('too_small') && (name.dirty || name.touched)) {
        <mat-error> {{ name.getError('too_small') }} </mat-error>
      }
    </mat-form-field>

    <mat-form-field>
      <mat-label>Email</mat-label>
      <input [formControl]="email" matInput />
      @if (email.hasError('required') && (email.dirty || email.touched)) {
        <mat-error> Email is required </mat-error>
      } @else if (
        email.hasError('too_small') && (email.dirty || email.touched)
      ) {
        <mat-error> {{ email.getError('too_small') }} </mat-error>
      }
    </mat-form-field>

    <mat-form-field>
      <mat-label>Password</mat-label>
      <input [formControl]="password" matInput />
      @if (
        password.hasError('required') && (password.dirty || password.touched)
      ) {
        <mat-error> Password is required </mat-error>
      } @else if (
        password.hasError('invalid_string') &&
        (password.dirty || password.touched)
      ) {
        <mat-error> {{ password.getError('invalid_string') }} </mat-error>
      }
    </mat-form-field>

    <mat-form-field>
      <mat-label>Confirm Password</mat-label>
      <input [formControl]="confirmPassword" matInput />
      @if (
        confirmPassword.hasError('required') &&
        (confirmPassword.dirty || confirmPassword.touched)
      ) {
        <mat-error> Confirm password is required </mat-error>
      } @else if (
        confirmPassword.hasError('too_small') &&
        (confirmPassword.dirty || confirmPassword.touched)
      ) {
        <mat-error>
          {{ confirmPassword.getError('too_small') }}
        </mat-error>
      } @else if (
        confirmPassword.hasError('noMatching') &&
        (confirmPassword.dirty || confirmPassword.touched)
      ) {
        <mat-error> Passwords do not match </mat-error>
      }
    </mat-form-field>

    <button
      [disabled]="registerForm.invalid"
      (click)="onSignUp()"
      color="primary"
      mat-flat-button
      type="button"
    >
      Sign Up
    </button>
  </form>
</div>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/register/register.component.scss
:host {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100vw;
  height: 100vh;
  background: var(--main-color)
}

.container {
  display: flex;
  overflow: hidden;
  justify-content: space-between;
  width: 50rem;
  border-radius: 0.5rem;
  background: var(--white-color);

  &__info {
    display: flex;
    align-items: center;
    flex-direction: column;
    justify-content: center;
    padding: 2rem;
    color: var(--white-color);
    background: var(--secondary-color)
  }

  &__form {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    padding: 3rem;

    &__title {
      text-align: center;
      color: var(--main-color);
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/auth/register/register.component.ts
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatError, MatFormField, MatLabel } from '@angular/material/form-field';
import { MatInput } from '@angular/material/input';
import { MatButton } from '@angular/material/button';
import { RouterLink } from '@angular/router';
import { AuthService } from '@lib/services';
import {
  FormControl,
  FormGroup,
  ReactiveFormsModule,
  Validators,
} from '@angular/forms';
import { zodValidator } from '@lib/validators/zod-validator.validator';
import { BaseRegisterSchema } from '@myworkspace/data-models';
import { matchValidator } from '@lib/validators/match-validator';
import { HttpErrorResponse } from '@angular/common/http';
import { ToastrService } from 'ngx-toastr';

@Component({
  selector: 'app-register',
  standalone: true,
  imports: [
    CommonModule,
    MatFormField,
    MatInput,
    MatLabel,
    MatButton,
    RouterLink,
    ReactiveFormsModule,
    MatError,
  ],
  templateUrl: './register.component.html',
  styleUrl: './register.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class RegisterComponent {
  private authSvc = inject(AuthService);
  private toastrSvc = inject(ToastrService);

  name = new FormControl('', [
    zodValidator(BaseRegisterSchema.shape.name),
    Validators.required,
  ]);
  email = new FormControl('', [
    zodValidator(BaseRegisterSchema.shape.email),
    Validators.required,
  ]);
  password = new FormControl('', [
    zodValidator(BaseRegisterSchema.shape.password),
    Validators.required,
  ]);
  confirmPassword = new FormControl('', [
    matchValidator('password'),
    Validators.required,
  ]);

  registerForm = new FormGroup({
    name: this.name,
    email: this.email,
    password: this.password,
    confirmPassword: this.confirmPassword,
  });

  onSignUp() {
    if (this.registerForm.invalid) {
      return;
    }

    this.authSvc
      .register(
        this.name.value as string,
        this.email.value as string,
        this.password.value as string,
        this.confirmPassword.value as string,
      )
      .subscribe({
        complete: () => {
          this.toastrSvc.success('Registration successful!');
        },
        error: (error: HttpErrorResponse) => {
          this.toastrSvc.error(error.error.message);
        },
      });
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/dashboard.component.html
<app-navbar [isHandset]="isHandset$ | async">
  <router-outlet></router-outlet>
</app-navbar>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/dashboard.component.scss


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/dashboard.component.ts
import { ChangeDetectionStrategy, Component, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NavbarComponent } from '@lib/components';
import { BreakpointObserver, Breakpoints } from '@angular/cdk/layout';
import { map, shareReplay } from 'rxjs/operators';
import { Observable } from 'rxjs';
import { RouterOutlet } from '@angular/router';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';

@Component({
  selector: 'app-dashboard',
  standalone: true,
  imports: [CommonModule, NavbarComponent, RouterOutlet],
  templateUrl: './dashboard.component.html',
  styleUrl: './dashboard.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DashboardComponent {
  private readonly breakpointObserver = inject(BreakpointObserver);

  isHandset$: Observable<boolean> = this.breakpointObserver
    .observe(Breakpoints.Handset)
    .pipe(
      map((result) => result.matches),
      shareReplay(1),
      takeUntilDestroyed(),
    );
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/done/done.component.html
<p>done works!</p>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/done/done.component.scss


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/done/done.component.ts
import { ChangeDetectionStrategy, Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-done',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './done.component.html',
  styleUrl: './done.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DoneComponent {}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/inbox/inbox.component.html
<p>inbox works!</p>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/inbox/inbox.component.scss


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/inbox/inbox.component.ts
import { ChangeDetectionStrategy, Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-inbox',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './inbox.component.html',
  styleUrl: './inbox.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class InboxComponent {}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/index.ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: '',
    title: 'Dashboard',
    loadComponent: async () =>
      await import('@pages/dashboard/dashboard.component').then(
        (m) => m.DashboardComponent,
      ),
    children: [
      {
        path: '',
        title: 'Recent Tasks',
        loadComponent: async () =>
          await import('./recent/recent.component').then(
            (m) => m.RecentComponent,
          ),
      },
      {
        path: 'done',
        title: 'Done Tasks',
        loadComponent: async () =>
          await import('./done/done.component').then((m) => m.DoneComponent),
      },
      {
        path: 'inbox',
        title: 'Inbox',
        loadComponent: async () =>
          await import('./inbox/inbox.component').then((m) => m.InboxComponent),
      },
    ],
  },
];


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/recent/recent.component.html
<p>recent works!</p>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/recent/recent.component.scss


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/app/pages/dashboard/recent/recent.component.ts
import { ChangeDetectionStrategy, Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-recent',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './recent.component.html',
  styleUrl: './recent.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class RecentComponent {}

File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>todo-app</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
  <body class="mat-typography">
    <app-root></app-root>
  </body>
</html>


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/main.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, appConfig).catch((err) =>
  console.error(err)
);


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/styles.scss
// Custom Theming for Angular Material
// For more information: https://material.angular.io/guide/theming
@use '@angular/material' as mat;
// Plus imports for other components in your app.

// Include the common styles for Angular Material. We include this here so that you only
// have to load a single css file for Angular Material in your app.
// Be sure that you only ever include this mixin once!
@include mat.core();

// Define the palettes for your theme using the Material Design palettes available in palette.scss
// (imported above). For each palette, you can optionally specify a default, lighter, and darker
// hue. Available color palettes: https://material.io/design/color/
$todo-app-primary: mat.define-palette(mat.$indigo-palette);
$todo-app-accent: mat.define-palette(mat.$pink-palette, A200, A100, A400);

// The warn palette is optional (defaults to red).
$todo-app-warn: mat.define-palette(mat.$red-palette);

// Create the theme object. A theme consists of configurations for individual
// theming systems such as "color" or "typography".
$todo-app-theme: mat.define-light-theme(
  (
    color: (
      primary: $todo-app-primary,
      accent: $todo-app-accent,
      warn: $todo-app-warn,
    ),
    typography: mat.define-typography-config(),
    density: 0,
  )
);

// Include theme styles for core and each component used in your app.
// Alternatively, you can import and @include the theme mixins for each component
// that you are using.
@include mat.all-component-themes($todo-app-theme);

/* You can add global styles to this file, and also import other style files */

:root {
  --main-color: 26, 121, 130;
  --secondary-color: 41, 222, 182;
  --white-color: 249, 255, 254;
}

* {
  box-sizing: border-box;
}

html,
body {
  height: 100%;
}
body {
  font-family: Roboto, 'Helvetica Neue', sans-serif;
  margin: 0;
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/src/test-setup.ts
// @ts-expect-error https://thymikee.github.io/jest-preset-angular/docs/getting-started/test-environment
globalThis.ngJest = {
  testEnvironmentOptions: {
    errorOnUnknownElements: true,
    errorOnUnknownProperties: true,
  },
};
import 'jest-preset-angular/setup-jest';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/tsconfig.app.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "types": []
  },
  "files": ["src/main.ts"],
  "include": ["src/**/*.d.ts"],
  "exclude": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts"]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/tsconfig.editor.json
{
  "extends": "./tsconfig.json",
  "include": ["src/**/*.ts"],
  "compilerOptions": {},
  "exclude": ["jest.config.ts", "src/**/*.test.ts", "src/**/*.spec.ts"]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/tsconfig.json
{
  "compilerOptions": {
    "target": "es2022",
    "useDefineForClassFields": false,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "noImplicitOverride": true,
    "baseUrl": ".",
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "paths": {
      "@lib/*": ["src/app/lib/*"],
      "@pages/*": ["src/app/pages/*"],
      "@env/*": ["src/environments/*"],
      "@myworkspace/data-models": ["../../shared/data-models/src/index.ts"]
    },
    "noFallthroughCasesInSwitch": true
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.editor.json"
    },
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.spec.json"
    }
  ],
  "extends": "../../tsconfig.base.json",
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-app/tsconfig.spec.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "module": "commonjs",
    "target": "es2016",
    "types": ["jest", "node"]
  },
  "files": ["src/test-setup.ts"],
  "include": [
    "jest.config.ts",
    "src/**/*.test.ts",
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/.eslintrc.json
{
  "extends": ["../../.eslintrc.json"],
  "ignorePatterns": ["!**/*"],
  "overrides": [
    {
      "files": ["*.ts", "*.tsx", "*.js", "*.jsx"],
      "rules": {}
    },
    {
      "files": ["*.ts", "*.tsx"],
      "rules": {}
    },
    {
      "files": ["*.js", "*.jsx"],
      "rules": {}
    }
  ]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/jest.config.ts
/* eslint-disable */
export default {
  displayName: 'todo-server',
  preset: '../../jest.preset.js',
  testEnvironment: 'node',
  transform: {
    '^.+\\.[tj]s$': ['ts-jest', { tsconfig: '<rootDir>/tsconfig.spec.json' }],
  },
  moduleFileExtensions: ['ts', 'js', 'html'],
  coverageDirectory: '../../coverage/apps/todo-server',
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240419080108_init/migration.sql
-- CreateTable
CREATE TABLE "Post" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "content" TEXT,
    "published" BOOLEAN NOT NULL DEFAULT false,
    "authorId" INTEGER NOT NULL,

    CONSTRAINT "Post_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Profile" (
    "id" SERIAL NOT NULL,
    "bio" TEXT,
    "userId" INTEGER NOT NULL,

    CONSTRAINT "Profile_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Profile_userId_key" ON "Profile"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- AddForeignKey
ALTER TABLE "Post" ADD CONSTRAINT "Post_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Profile" ADD CONSTRAINT "Profile_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240419083352_init/migration.sql
/*
  Warnings:

  - The primary key for the `User` table will be changed. If it partially fails, the table could be left without primary key constraint.
  - You are about to drop the `Post` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `Profile` table. If the table is not empty, all the data it contains will be lost.
  - Added the required column `password` to the `User` table without a default value. This is not possible if the table is not empty.
  - Added the required column `updatedAt` to the `User` table without a default value. This is not possible if the table is not empty.

*/
-- DropForeignKey
ALTER TABLE "Post" DROP CONSTRAINT "Post_authorId_fkey";

-- DropForeignKey
ALTER TABLE "Profile" DROP CONSTRAINT "Profile_userId_fkey";

-- AlterTable
ALTER TABLE "User" DROP CONSTRAINT "User_pkey",
ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "password" VARCHAR(255) NOT NULL,
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL,
ALTER COLUMN "id" DROP DEFAULT,
ALTER COLUMN "id" SET DATA TYPE TEXT,
ADD CONSTRAINT "User_pkey" PRIMARY KEY ("id");
DROP SEQUENCE "User_id_seq";

-- DropTable
DROP TABLE "Post";

-- DropTable
DROP TABLE "Profile";

-- CreateTable
CREATE TABLE "Task" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "description" TEXT,
    "dueDate" TIMESTAMP(3),
    "completed" BOOLEAN NOT NULL DEFAULT false,
    "categoryId" TEXT,
    "userId" TEXT NOT NULL,

    CONSTRAINT "Task_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Category" (
    "id" TEXT NOT NULL,
    "name" VARCHAR(255) NOT NULL,

    CONSTRAINT "Category_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "Task" ADD CONSTRAINT "Task_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Task" ADD CONSTRAINT "Task_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240419085235_init/migration.sql
/*
  Warnings:

  - Made the column `categoryId` on table `Task` required. This step will fail if there are existing NULL values in that column.

*/
-- DropForeignKey
ALTER TABLE "Task" DROP CONSTRAINT "Task_categoryId_fkey";

-- AlterTable
ALTER TABLE "Task" ALTER COLUMN "categoryId" SET NOT NULL;

-- AddForeignKey
ALTER TABLE "Task" ADD CONSTRAINT "Task_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240425085502_init/migration.sql
/*
  Warnings:

  - Made the column `name` on table `User` required. This step will fail if there are existing NULL values in that column.

*/
-- CreateEnum
CREATE TYPE "TokenType" AS ENUM ('ACCESS', 'REFRESH', 'RESET_PASSWORD', 'VERIFY_EMAIL');

-- AlterTable
ALTER TABLE "User" ALTER COLUMN "name" SET NOT NULL;

-- CreateTable
CREATE TABLE "Token" (
    "id" SERIAL NOT NULL,
    "token" TEXT NOT NULL,
    "type" "TokenType" NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL,
    "blacklisted" BOOLEAN NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,

    CONSTRAINT "Token_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "Token" ADD CONSTRAINT "Token_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240430130308_init/migration.sql
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('USER', 'ADMIN');

-- AlterTable
ALTER TABLE "User" ADD COLUMN     "role" "Role" NOT NULL DEFAULT 'USER';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/20240521081151_init/migration.sql
-- AlterTable
ALTER TABLE "Token" ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/migrations/migration_lock.toml
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"

File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/prisma/schema.prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String
  password  String   @db.VarChar(255)
  role      Role     @default(USER)
  tasks     Task[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Token     Token[]
}

model Token {
  id          Int       @id @default(autoincrement())
  token       String
  type        TokenType
  expires     DateTime
  blacklisted Boolean
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation(fields: [userId], references: [id])
  userId      String
}

model Task {
  id          String    @id @default(uuid())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  title       String    @db.VarChar(255)
  description String?
  dueDate     DateTime?
  completed   Boolean   @default(false)
  categoryId  String
  category    Category  @relation(fields: [categoryId], references: [id])
  userId      String
  user        User      @relation(fields: [userId], references: [id])
}

model Category {
  id    String @id @default(uuid())
  name  String @db.VarChar(255)
  tasks Task[]
}

enum Role {
  USER
  ADMIN
}

enum TokenType {
  ACCESS
  REFRESH
  RESET_PASSWORD
  VERIFY_EMAIL
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/project.json
{
  "name": "todo-server",
  "$schema": "../../node_modules/nx/schemas/project-schema.json",
  "sourceRoot": "apps/todo-server/src",
  "projectType": "application",
  "tags": [],
  "targets": {
    "build": {
      "executor": "@nx/esbuild:esbuild",
      "outputs": ["{options.outputPath}"],
      "defaultConfiguration": "production",
      "options": {
        "platform": "node",
        "outputPath": "dist/apps/todo-server",
        "format": ["cjs"],
        "bundle": false,
        "main": "apps/todo-server/src/main.ts",
        "tsConfig": "apps/todo-server/tsconfig.app.json",
        "assets": ["apps/todo-server/src/assets"],
        "generatePackageJson": true,
        "esbuildOptions": {
          "sourcemap": true,
          "outExtension": {
            ".js": ".js"
          }
        }
      },
      "configurations": {
        "development": {},
        "production": {
          "esbuildOptions": {
            "sourcemap": false,
            "outExtension": {
              ".js": ".js"
            }
          }
        }
      }
    },
    "serve": {
      "executor": "@nx/js:node",
      "defaultConfiguration": "development",
      "options": {
        "buildTarget": "todo-server:build"
      },
      "configurations": {
        "development": {
          "buildTarget": "todo-server:build:development"
        },
        "production": {
          "buildTarget": "todo-server:build:production"
        }
      }
    },
    "test": {
      "executor": "@nx/jest:jest",
      "outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
      "options": {
        "jestConfig": "apps/todo-server/jest.config.ts"
      }
    }
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/app.ts
import express from 'express';

import compression from 'compression';
import helmet from 'helmet';
import { xss } from 'express-xss-sanitizer';
import cors from 'cors';
import passport from 'passport';
import httpStatus from 'http-status';

import routes from './routes/v1';

import { errorConverter, errorHandler } from './middlewares';

import ApiError from './utils/ApiError';

import { jwtStrategy } from './config/passport';

const app = express();

app.use(helmet());

app.use(express.json());

app.use(express.urlencoded({ extended: true }));

app.use(xss());

app.use(compression());

app.use(cors());

app.use(passport.initialize());
passport.use('jwt', jwtStrategy);

app.use('/v1', routes);

app.use((req, res, next) => {
  next(new ApiError(httpStatus.NOT_FOUND, 'Not found'));
});

app.use(errorConverter);

app.use(errorHandler);

export default app;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/assets/.gitkeep


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/client.ts
import { PrismaClient } from '@prisma/client';

// Singleton instance
let prisma: PrismaClient;

if (!prisma) {
  prisma = new PrismaClient();

  process.on('SIGTERM', async () => await prisma.$disconnect());
}

export default prisma;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/config/config.ts
import dotenv from 'dotenv';
import path from 'path';
import { z } from 'zod';
import { fromError } from 'zod-validation-error';

dotenv.config({ path: path.join(process.cwd(), '.env') });

const envVarsSchema = z.object({
  NODE_ENV: z
    .enum(['production', 'development', 'test'])
    .default('development'),
  PORT: z
    .string()
    .transform((x) => Number(x))
    .default('3000'),
  JWT_SECRET: z.string().min(1).describe('JWT secret key'),
  JWT_ACCESS_EXPIRATION_MINUTES: z
    .string()
    .transform((x) => Number(x))
    .default('30')
    .describe('minutes after which access tokens expire'),
  JWT_REFRESH_EXPIRATION_DAYS: z
    .string()
    .transform((x) => Number(x))
    .default('30')
    .describe('days after which refresh tokens expire'),
  JWT_RESET_PASSWORD_EXPIRATION_MINUTES: z
    .string()
    .transform((x) => Number(x))
    .default('10')
    .describe('minutes after which reset password token expires'),
  JWT_VERIFY_EMAIL_EXPIRATION_MINUTES: z
    .string()
    .transform((x) => Number(x))
    .default('10')
    .describe('minutes after which verify email token expires'),
});

// Parse and validate environment variables
const envVars = envVarsSchema.safeParse(process.env);

if (!envVars.success) {
  const validationError = fromError(envVars.error);
  console.error(' Invalid environment variables:', validationError.details);
  process.exit(1);
}

export default {
  env: envVars.data.NODE_ENV,
  port: envVars.data.PORT,
  jwt: {
    secret: envVars.data.JWT_SECRET,
    accessExpirationMinutes: envVars.data.JWT_ACCESS_EXPIRATION_MINUTES,
    refreshExpirationDays: envVars.data.JWT_REFRESH_EXPIRATION_DAYS,
    resetPasswordExpirationMinutes:
      envVars.data.JWT_RESET_PASSWORD_EXPIRATION_MINUTES,
    verifyEmailExpirationMinutes:
      envVars.data.JWT_VERIFY_EMAIL_EXPIRATION_MINUTES,
  },
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/config/passport.ts
import {
  ExtractJwt,
  Strategy as JwtStrategy,
  StrategyOptionsWithoutRequest,
  VerifyCallback,
} from 'passport-jwt';
import { TokenType } from '@prisma/client';
import prisma from '../client';
import config from './config';

const jwtOptions: StrategyOptionsWithoutRequest = {
  secretOrKey: config.jwt.secret,
  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
};

const jwtVerify: VerifyCallback = async (payload, done) => {
  try {
    if (payload.type !== TokenType.ACCESS) {
      throw new Error('Invalid token type');
    }

    const user = await prisma.user.findUnique({
      select: {
        id: true,
        email: true,
        name: true,
      },
      where: { id: payload.sub },
    });
    if (!user) {
      return done(null, false);
    }
    done(null, user);
  } catch (error) {
    done(error, false);
  }
};

export const jwtStrategy = new JwtStrategy(jwtOptions, jwtVerify);


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/config/roles.ts
import { Role } from '@prisma/client';

const allRoles = {
  [Role.USER]: [],
  [Role.ADMIN]: ['getUsers', 'manageUsers'],
};

export const roles = Object.keys(allRoles);
export const roleRights = new Map(Object.entries(allRoles));


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/controllers/auth.controller.ts
import { Request, Response } from 'express';

import httpStatus from 'http-status';

import {
  ILogin,
  IRegister,
  LoginSchema,
  RegisterSchema,
} from '@myworkspace/data-models';

import { authService, tokenService, userService } from '../services';

import { catchAsync } from '../utils';

import { TokenType } from '@prisma/client';

export const register = catchAsync(async (req: Request, res: Response) => {
  RegisterSchema.parse(req.body);

  const { email, name, password } = req.body as IRegister;

  const user = await userService.createUser(email, name, password);

  return res.status(httpStatus.CREATED).json({
    message: 'User created successfully',
    data: { user },
  });
});

export const login = catchAsync(async (req: Request, res: Response) => {
  LoginSchema.parse(req.body);

  const { email, password } = req.body as ILogin;

  const user = await authService.loginUserWithEmailAndPassword(email, password);
  const tokens = await tokenService.generateAuthTokens(user);

  return res.status(httpStatus.OK).json({
    message: 'Login successful',
    data: { user, tokens },
  });
});

export const refreshToken = catchAsync(async (req: Request, res: Response) => {
  const { refreshToken } = req.body;

  const refreshTokenData = await tokenService.verifyToken(
    refreshToken,
    TokenType.REFRESH,
  );

  if (!refreshTokenData) {
    return res.status(httpStatus.UNAUTHORIZED).json({
      message: 'Invalid refresh token',
    });
  }

  const user = await userService.getUserById(refreshTokenData.userId);

  if (!user) {
    return res.status(httpStatus.NOT_FOUND).json({
      message: 'User not found',
    });
  }

  const accessToken = await tokenService.generateAccessToken(user);

  return res.status(httpStatus.OK).json({
    message: 'Token validated successfully',
    data: { user, accessToken },
  });
});


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/controllers/index.ts
export * as authController from './auth.controller';
export * as taskController from './task.controller';
export * as userController from './user.controller';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/controllers/task.controller.ts
import { Request, Response } from 'express';

export const test = (req: Request, res: Response) => {
  res.status(404).json({ message: 'Hello' });
};

// export const hello = (req: Request, res: Response) => {
//   res.status(200).json({ message: 'Hello API' });
// };


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/controllers/user.controller.ts
import { Request, Response } from 'express';
import httpStatus from 'http-status';
import { userService } from '../services';
import { catchAsync } from '../utils';

export const getUser = catchAsync(async (req: Request, res: Response) => {
  const { userId } = req.params;

  const user = await userService.getUserById(userId);

  if (!user) {
    return res.status(httpStatus.NOT_FOUND).json({
      message: 'User not found',
    });
  }

  return res.status(httpStatus.OK).json({
    message: 'User retrieved successfully',
    data: { user },
  });
});


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/main.ts
import { Server } from 'http';
import prisma from './client';
import app from './app';
import config from './config/config';

let server: Server;

prisma.$connect().then(() => {
  server = app.listen(config.port, () => {
    console.log(`Server is running on port ${config.port}`);
  });
});

const exitHandler = () => {
  if (server) {
    server.close(() => {
      console.log('Server closed');
      process.exit(1);
    });
  } else {
    process.exit(1);
  }
};

const unexpectedErrorHandler = (error: Error) => {
  console.log(error);
  exitHandler();
};

process.on('uncaughtException', unexpectedErrorHandler);
process.on('unhandledRejection', unexpectedErrorHandler);

process.on('SIGTERM', () => {
  console.log('SIGTERM received');
  if (server) {
    server.close();
  }
});


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/middlewares/auth.ts
import passport, { AuthenticateCallback } from 'passport';
import httpStatus from 'http-status';
import ApiError from '../utils/ApiError';
import { roleRights } from '../config/roles';
import { NextFunction, Request, Response } from 'express';
import { User } from '@prisma/client';

const verifyCallback: (
  req: Request,
  resolve: (value?: unknown) => void,
  reject: (reason?: unknown) => void,
  requiredRights: string[]
) => AuthenticateCallback =
  (req, resolve, reject, requiredRights) =>
  async (
    err: any,
    user?: User | false | null,
    info?: object | string | Array<string | undefined>
  ): Promise<void> => {
    if (err || info || !user) {
      return reject(
        new ApiError(httpStatus.UNAUTHORIZED, 'Please authenticate')
      );
    }
    req.user = user;

    if (requiredRights.length) {
      const userRights = roleRights.get(user.role) ?? [];
      const hasRequiredRights = requiredRights.every((requiredRight) =>
        userRights.includes(requiredRight)
      );
      if (!hasRequiredRights && req.params.userId !== user.id) {
        return reject(new ApiError(httpStatus.FORBIDDEN, 'Forbidden'));
      }
    }

    resolve();
  };

const auth =
  (...requiredRights: string[]) =>
  async (req: Request, res: Response, next: NextFunction) => {
    return new Promise((resolve, reject) => {
      passport.authenticate(
        'jwt',
        { session: false },
        verifyCallback(req, resolve, reject, requiredRights)
      )(req, res, next);
    })
      .then(() => next())
      .catch((err) => next(err));
  };

export default auth;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/middlewares/error.ts
import { ErrorRequestHandler, NextFunction, Request, Response } from 'express';
import { Prisma } from '@prisma/client';
import httpStatus from 'http-status';
import ApiError from '../utils/ApiError';
import { ZodError } from 'zod';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import { fromError } from 'zod-validation-error';

export const errorConverter: ErrorRequestHandler = (
  err: PrismaClientKnownRequestError | ZodError | ApiError,
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  let error = err;

  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    const statusCode = httpStatus.BAD_REQUEST;
    const message = error.message;
    error = new ApiError(statusCode, message, false);
  }

  if (error instanceof ZodError) {
    const validationError = fromError(error);
    const statusCode = httpStatus.BAD_REQUEST;
    const message = validationError.message;

    error = new ApiError(statusCode, message, false, validationError.details);
  }

  return next(error);
};

export const errorHandler: ErrorRequestHandler = (
  err: ApiError,
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  const { statusCode, message, errors } = err;

  const response = {
    statusCode,
    message,
    errors,
  };

  return res.status(statusCode).json(response);
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/middlewares/index.ts
export * from './error';
export * from './auth';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/routes/v1/auth.route.ts
import express from 'express';

import { authController } from '../../controllers';

const router = express.Router();

router.post('/register', authController.register);

router.post('/login', authController.login);

router.post('/refresh-token', authController.refreshToken);

export default router;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/routes/v1/index.ts
import express from 'express';
import authRoute from './auth.route';
import taskRoute from './task.route';
import userRoute from './user.route';

const router = express.Router();

const defaultRoutes = [
  {
    path: '/auth',
    route: authRoute,
  },
  {
    path: '/task',
    route: taskRoute,
  },
  {
    path: '/user',
    route: userRoute,
  },
];

defaultRoutes.forEach((route) => {
  router.use(route.path, route.route);
});

export default router;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/routes/v1/task.route.ts
import express from 'express';

import { taskController } from '../../controllers';
import auth from '../../middlewares/auth';

const router = express.Router();

router.post('/test', auth(), taskController.test);

export default router;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/routes/v1/user.route.ts
import express from 'express';

import { userController } from '../../controllers';

import auth from '../../middlewares/auth';

const router = express.Router();

router.get('/:userId', auth(), userController.getUser);
// router.put('/:userId', auth(), userController.updateUser);
// router.delete('/:userId', auth(), userController.deleteUser);

export default router;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/services/auth.service.ts
import prisma from '../client';
import ApiError from '../utils/ApiError';
import { matchPassword } from '../utils';
import httpStatus from 'http-status';
import { exclude } from '../utils/exclude';
import { tokenService } from '.';
import { TokenType } from '@prisma/client';

export const loginUserWithEmailAndPassword = async (
  email: string,
  password: string,
) => {
  const user = await prisma.user.findUnique({
    where: {
      email,
    },
  });

  if (!user) throw new ApiError(httpStatus.NOT_FOUND, 'User not found');

  const isPasswordValid = await matchPassword(password, user.password);

  if (!isPasswordValid)
    throw new ApiError(httpStatus.BAD_REQUEST, 'Invalid password');

  return exclude(user, ['password', 'createdAt', 'updatedAt']);
};

export const refreshAuth = async (refreshToken: string) => {
  try {
    const refreshTokenData = await tokenService.verifyToken(
      refreshToken,
      TokenType.REFRESH,
    );

    const { userId } = refreshTokenData;

    await prisma.token.delete({
      where: {
        id: refreshTokenData.id,
      },
    });

    return tokenService.generateAuthTokens({ id: userId });
  } catch (error) {
    throw new ApiError(httpStatus.UNAUTHORIZED, 'Please Authenticate');
  }
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/services/index.ts
export * as authService from './auth.service';
export * as tokenService from './token.service';
export * as userService from './user.service';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/services/token.service.ts
import { BaseUserSchema, ITokens } from '@myworkspace/data-models';
import z from 'zod';
import { TokenType } from '@prisma/client';
import jwt from 'jsonwebtoken';
import config from '../config/config.js';
import prisma from '../client.js';

interface JwtPayload {
  sub: string;
  iat: number;
  exp: number;
  type: TokenType;
}

const generateToken = (
  userId: string,
  expires: Date,
  type: TokenType,
  secret = config.jwt.secret,
): string => {
  const payload: JwtPayload = {
    sub: userId,
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(expires.getTime() / 1000),
    type,
  };
  return jwt.sign(payload, secret);
};

const saveToken = async (
  userId: string,
  token: string,
  expires: Date,
  type: TokenType,
  blacklisted = false,
) => {
  const existingToken = await prisma.token.findFirst({
    where: {
      userId,
      type,
    },
  });

  if (existingToken) {
    await prisma.token.update({
      where: {
        id: existingToken.id,
      },
      data: {
        token,
        expires,
        blacklisted,
      },
    });

    return existingToken;
  }

  return await prisma.token.create({
    data: {
      userId,
      token,
      expires,
      type,
      blacklisted,
    },
  });
};

export const generateAccessToken = async (
  user: z.infer<typeof BaseUserSchema>,
) => {
  const { id: userId } = user;

  const expires = Date.now() + config.jwt.accessExpirationMinutes * 60 * 1000;

  const token = generateToken(userId, new Date(expires), TokenType.ACCESS);

  return { token, expires, type: TokenType.ACCESS };
};

export const generateAuthTokens = async (
  user: z.infer<typeof BaseUserSchema>,
): Promise<ITokens> => {
  const { id: userId } = user;

  const accessTokenExpires =
    Date.now() + config.jwt.accessExpirationMinutes * 60 * 1000;

  const refreshTokenExpires =
    Date.now() + config.jwt.refreshExpirationDays * 24 * 60 * 60 * 1000;

  const accessToken = generateToken(
    userId,
    new Date(accessTokenExpires),
    TokenType.ACCESS,
  );

  const refreshToken = generateToken(
    userId,
    new Date(refreshTokenExpires),
    TokenType.REFRESH,
  );

  await saveToken(
    userId,
    refreshToken,
    new Date(refreshTokenExpires),
    TokenType.REFRESH,
  );

  return {
    access: {
      token: accessToken,
      expires: accessTokenExpires,
      type: TokenType.ACCESS,
    },
    refresh: {
      token: refreshToken,
      expires: refreshTokenExpires,
      type: TokenType.REFRESH,
    },
  };
};

export const verifyToken = async (token: string, type: TokenType) => {
  const payload = jwt.verify(token, config.jwt.secret) as JwtPayload;

  const userId = payload.sub;

  if (payload.type !== type) throw new Error('Invalid token type');

  const tokenData = await prisma.token.findFirst({
    where: {
      userId,
      token,
      type,
      blacklisted: false,
    },
  });

  if (!tokenData) throw new Error('Token not found!');

  return tokenData;
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/services/user.service.ts
import prisma from '../client';
import ApiError from '../utils/ApiError';
import httpStatus from 'http-status';
import { encrypt, exclude } from '../utils';

export const createUser = async (
  email: string,
  name: string,
  password: string,
) => {
  const userExists = await prisma.user.findUnique({
    where: {
      email,
    },
  });

  if (userExists)
    throw new ApiError(httpStatus.CONFLICT, 'User already exists');

  const hashedPassword = await encrypt(password);

  const user = await prisma.user.create({
    data: {
      email,
      name,
      password: hashedPassword,
    },
  });

  return exclude(user, ['password', 'createdAt', 'updatedAt']);
};

export const getUserById = async (id: string) => {
  const user = await prisma.user.findUnique({
    where: {
      id,
    },
  });

  if (!user) throw new ApiError(httpStatus.NOT_FOUND, 'User not found');

  return exclude(user, ['password', 'createdAt', 'updatedAt']);
};

export const getUserByEmail = async (email: string) => {
  const user = await prisma.user.findUnique({
    where: {
      email,
    },
  });

  if (!user) throw new ApiError(httpStatus.NOT_FOUND, 'User not found');

  return exclude(user, ['password', 'createdAt', 'updatedAt']);
};

export const getUsers = async () => {
  const users = await prisma.user.findMany();
  return users;
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/ApiError.ts
class ApiError extends Error {
  statusCode: number;
  isOperational: boolean;
  errors: any[];

  constructor(
    statusCode: number,
    message?: string,
    isOperational = true,
    errors: any[] = []
  ) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.errors = errors;
  }
}

export default ApiError;


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/catchAsync.ts
import { NextFunction, Request, RequestHandler, Response } from 'express';

export const catchAsync =
  (fn: RequestHandler) => (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/encryption.ts
import bcrypt from 'bcrypt';

export const encrypt = async (password: string) => {
  return await bcrypt.hash(password, 8);
};

export const matchPassword = (password: string, userPassword: string) => {
  return bcrypt.compare(password, userPassword);
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/exclude.ts
export const exclude = <Type, Key extends keyof Type>(
  obj: Type,
  keys: Key[]
): Omit<Type, Key> => {
  for (const key of keys) {
    delete obj[key];
  }
  return obj;
};


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/src/utils/index.ts
export * from './ApiError';
export * from './catchAsync';
export * from './encryption';
export * from './exclude';


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/tsconfig.app.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "module": "commonjs",
    "types": ["node"]
  },
  "exclude": ["jest.config.ts", "src/**/*.spec.ts", "src/**/*.test.ts"],
  "include": ["src/**/*.ts"]
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.spec.json"
    }
  ],
  "compilerOptions": {
    "esModuleInterop": true
  }
}


File: /Users/ursachianualexandru/Desktop/Todo/myworkspace/apps/todo-server/tsconfig.spec.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "module": "commonjs",
    "types": ["jest", "node"]
  },
  "include": [
    "jest.config.ts",
    "src/**/*.test.ts",
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}


